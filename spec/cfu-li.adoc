== Custom Function Unit Logic Interface (CFU-LI)

The CFU-LI defines a set of common hardware logic signaling interfaces
enabling straightforward, correct composition of CPUs and CFUs. In the
CFU-LI, a CPU is a requester and a CFU is a responder. The CPU sends
a CFU request and eventually receives a CFU response. For each request
there is exactly one response.

=== Definitions

[[cfu_request]]
A *CFU request (request)* is a group of CFU-LI signals that may
include request flow control, <<REQ_ID,REQ_ID>>, <<CFU_ID,CFU_ID>>,
<<CF_ID,CF_ID>>, <<STATE_ID,STATE_ID>>, the raw instruction, and integer
operands, produced by a CFU requester, conveying request data to a CFU.

A *CFU response (response)* is a group of CFU-LI signals that may include
response flow control, <<REQ_ID,REQ_ID>>, response status, and integer
result, produced by a CFU, conveying response data to a CFU requester.

[[REQ_ID]]
A *request ID (REQ_ID)* is a tag (a _magic cookie_) that correlates
a CFU request and its corresponding CFU response.

A *CFU response status (response status, status)* is a CFU-LI
success/error code produced by a CFU in response to receiving a
CFU request, indicating success or else an error in the request's
<<CFU_ID,CFU_ID>>, <<CF_ID,CF_ID>>, <<STATE_ID,STATE_ID>>, operation,
or a custom interface specific error.

A *CFU requester* (requester) is a core that sends CFU requests to CFU(s)
and receives CFU response(s) from CFUs.

A *CPU* is a CFU requester that implements RISC-V RV-I-Zicsr-Zicfu
instruction set, issues CFU requests upon issuing CF instructions,
and writes a destination register and the CFU status CSR in response to
CFU responses.

A *custom function unit (CFU, responder)* is a core that implements
one or more custom interfaces. It receives CFU requests and sends CFU
responses to CFU requesters. A CFU that also issues CFU requests is an
*intermediary CFU*; otherwise it is a *leaf CFU*.

A *Mux CFU (mux)* is an intermediary CFU. For each request received,
the mux either sends a response itself (e.g., a CFU_ERROR_CFU response)
or arbitrates and forwards the request to a subordinate CFU, and later
forwards the corresponding response to the original requester.

A *CFU feature level adapter (adapter)* is an intermediary CFU that
receives requests and sends responses at one CFU-LI feature level and
adapts them for and forwards them to a subordinate CFU with a lesser
feature level.

A *configured system (system)* is a computer system including one or
more CPUs and zero or more CFUs that implement a set of configured
custom interfaces.

=== Example configured system

<<configured-system>> illustrates a configured system composed of two
CPUs and five CFUs, plus a mux, and a level adapter for CFU~3~. Each CPU
has two harts. CFUs 0-2 are stateful and CFUs 3-4 are stateless. Each
stateful CFU has one state context per hart. CFU~1~ has an additional
state context per hart for isolated stateful requests from CFU~2~.

[[configured-system]]
.Configured system composed of two CPUs and five CFUs
image::composed-cfus.png[image,width=360]

In general, a CPU that issues one CFU request per cycle is directly
coupled to one CFU, usually a mux CFU. A system of CFUs forms a directed
acyclic graph.

=== CFU-LI feature levels

The CFU-LI is stratified into separate feature levels: -L0:combinational;
-L1: fixed latency; -L2: variable latency; -L3:elastic; and -L4:reordering.
Each feature level adds yet more CFU request and response
signals, module ports, and behaviors to the feature level below it.

[TIP]
====
Stratification keeps simple use cases simple and frugal, and makes more
complex use cases possible.
====

==== CFU-L0: combinational CFU

The CFU, which implements a stateless custom interface, computes a
combinational function of the CFU request, sending a CFU response after
some propagation delay. There is no flow control.

[TIP]
====
Example: combinational bitmanip unit with a population count custom function.
====

[[cfu-l1]]
==== CFU-L1: fixed latency CFU

Each cycle, the CFU computes a function of the CFU request *and the
specified state context, if any, updating the context*, sending a
CFU response after a configured *fixed non-negative number of clock
cycles*. With an initiation interval of II=1/cycle, there is no flow
control of requests or responses.

[TIP]
====
Examples: stateless: a pipelined multiplier; stateful: a pipelined
multiply-accumulate unit wherein the state is the current total.
====

[NOTE]
====
Perhaps minimum II should also be configurable, e.g. CFU_INIT_INTERVAL=1+.
====

==== CFU-L2: variable latency, request-only flow control CFU (variable latency CFU)

The CFU computes a function of the CFU request and the specified state
context, if any, updating the context, sending a CFU response, *in order,
in a later clock cycle*. There is *request flow control* so the CFU can
suspend receiving requests.

[TIP]
====
Example: a multiply-divide unit with a variable-latency multi-cycle
divide, with early-out, and which is not ready to receive requests while
the divider is busy.
====

==== CFU-L3: variable latency, request/response flow control CFU (elastic CFU)

The CFU computes a function of a CFU request and the specified state
context, if any, updating the context, sending a CFU response, in order,
in a later clock cycle. There is *request and response flow control*
so the CFU can suspend receiving requests and the requester can suspend
receiving responses.

[TIP]
====
Example: the above multiply-divide unit but also with response queueing
or elastic pipeline control to support response backpressure.
====

[NOTE]
====
Perhaps *streaming CFU* would be a better name.
====

==== CFU-L4: reordering CFU

The CFU computes a function of the CFU request and the specified state
context, if any, updating the context, and sending a CFU response in a
later clock cycle. *Responses for requests with the same state context
are sent in order, otherwise may be sent out of order*. There is request
and response flow control.

[TIP]
====
Example: a stateless, variable latency posit floating point unit, which,
having received a pdiv request then a pmul request, responds out of order,
sending the pmul response ahead of the pdiv response.
====

==== Feature levels summary

In summary, all CFU-LI feature levels have request and response function,
data, and status. Level 0 is combinational. Level 1 adds clocking,
fixed latency, and state contexts. Level 2 adds variable latency,
request flow control, request ID, and raw instruction. Level 3 adds
response flow control. Level 4 adds reordering. (<<levels-table>>.)

[[levels-table]]
.CFU-LI feature levels summary
[width="100%",cols="8%,17%,18%,20%,15%,9%,13%",options="header",]
|===
^|*Level* |*CFU type* ^a|
*Req valid, func, data, resp data, status*
^|*Clock, reset, clock enable, state ID, resp valid* ^|*Req ready, ID, raw insn, resp ID* ^|*Resp ready* ^|*Reorder responses*
^|0 |combinational ^|Y ^| ^| ^| ^|
^|1 |fixed latency ^|Y ^|Y ^| ^| ^|
^|2 |variable latency ^|Y ^|Y ^|Y ^| ^|
^|3 |elastic ^|Y ^|Y ^|Y ^|Y ^|
^|4 |reordering ^|Y ^|Y ^|Y ^|Y ^|Y
|===

[TIP]
====
Compared to all possible subsets of features, CFU-LI levels are
relatively simple and practical. Each level is a superset of lower
levels, simplifying composition of dissimilar CFUs using common CFU
feature level adapters.
====

=== CFU-LI signaling

CFU cores _of a particular feature level_ implement a common set
of request and response signals. <<cfu-signals>> lists all CFU-LI
signals of all feature levels in a canonical order: transaction
signals (request/response valid, ready, <<REQ_ID,REQ_ID>>), context
(<<CFU_ID,CFU_ID>>, <<STATE_ID,STATE_ID>>), function (raw instruction,
<<CF_ID,CF_ID>>), and data. The Level column indicates which levels introduce
which signals. The Dir column indicates the signal direction from the
perspective of a responder. The bit width of each bit vector is determined
by a width parameter, configurable per CFU
(§<<parameters>>).

[[cfu-signals]]
.All CFU-LI signals, by feature level
[width="100%",cols="11%,8%,22%,24%,35%",options="header",]
|===
^|*Level* ^|*Dir* |*Port* |*Width Parameter* |*Description*
^|1+ ^|in |`clk` | |clock
^|1+ ^|in |`rst` | |reset
^|1+ ^|in |`clk_en` | |clock enable
^| ^|in |`req_valid` | |request valid
^|2+ ^|out |`req_ready` | |request ready
^|2+ ^|in |`req_id` |`CFU_REQ_ID_W` |request <<REQ_ID,REQ_ID>>
^| ^|in |`req_cfu` |`CFU_CFU_ID_W` |request <<CFU_ID,CFU_ID>>
^|1+ ^|in |`req_state` |`CFU_STATE_ID_W` |request <<STATE_ID,STATE_ID>>
^|2+ ^|in |`req_insn` |`CFU_INSN_W` |request raw instruction
^| ^|in |`req_func` |`CFU_FUNC_ID_W` |request <<CF_ID,CF_ID>>
^| ^|in |`req_data0` |`CFU_DATA_W` |request operand data 0
^| ^|in |`req_data1` |`CFU_DATA_W` |request operand data 1
^|1+ ^|out |`resp_valid` | |response valid
^|3+ ^|in |`resp_ready` | |response ready
^|2+ ^|out |`resp_id` |`CFU_REQ_ID_W` |response ID
^| ^|out |`resp_status` |`CFU_STATUS_W` |response status
^| ^|out |`resp_data` |`CFU_DATA_W` |response data
|===

All signals are positive-true logic.
[NOTE]
====
It is unfortunate the custom function ID is *CF_ID* in the HW-SW interface
and *FUNC_ID* in the CFU-LI.
====

[[parameters]]
==== CFU-LI configuration parameters

<<width-parameters>> presents CFU-LI bit vector width parameters and
ranges of possible values.

[[width-parameters]]
.CFU-LI width configuration parameters
[width="100%",cols="8%,12%,18%,8%,10%,44%",options="header",]
|===
^|*Level* |*Quantity* |*Width Parameter* |*Range* |*Default* |*Description*
^|2+ |<<REQ_ID,REQ_ID>> |`CFU_REQ_ID_W` |0-64 |0 |request/response ID width
^| |<<CFU_ID,CFU_ID>> |`CFU_CFU_ID_W` |0-16 |0 |CFU_ID width
^|1+ |<<STATE_ID,STATE_ID>> |`CFU_STATE_ID_W` |0-16 |0 |STATE_ID width
^|2+ |`insn` |`CFU_INSN_W` |0, 32 |0 |raw instruction width
^| |<<CF_ID,CF_ID>> |`CFU_FUNC_ID_W` |0-10 |10 |CF_ID width
^| |`data` |`CFU_DATA_W` |32, 64 |32 |request/response data width
^| |`status` |`CFU_STATUS_W` |3 |3 |response status width
|===

[TIP]
====
Zero width bit vectors are problematic in some HDLs. Parameter signals
declared 0-bits wide should nevertheless be declared [0:0], driven 1'b0
by sender, and ignored by receiver.
====

[NOTE]
====
When `CFU_FUNC_ID_W<10`, how do standard custom functions (CF_ID in [0x3F0..0x3FF]) work?
====

<<other-parameters>> presents other CFU configuration parameters.

[[other-parameters]]
.CFU-LI: other CFU configuration parameters
[width="100%",cols="8%,21%,8%,9%,54%",options="header",]
|===
^|*Level* |*Parameter* |*Range* |*Default* |*Description*
^| |`CFU_VERSION` |100 |100 |CFU-LI version; 100 == 1.00
^| |`CFU_CFU_ID_MAX` |1+ |1 |number of CFUs at/below this CFU
^|1+ |`CFU_STATE_ID_MAX` |0+ |0 |number of custom interface state contexts
^|1 |`CFU_LATENCY` |0+ |1 |latency (clock cycles) from a request to its response
^|1 |`CFU_RESET_LATENCY` |0+ |0 |min. latency (clock cycles) from negation of reset to first request
|===

`CFU_VERSION` is the CFU-LI version number the CFU is configured to
implement, encoded as 100: the decimal version number.

[TIP]
====
This records, in code, the CFU-LI version implemented by a CFU, and
anticipates evolution of CFU-LI.
====

`CFU_CFU_ID_MAX` is the number of logical CFUs at/below this CFU. For
a leaf CFU this may be more than one when the CFU implements multiple
custom interfaces (including multiple versions of one custom interface).

`CFU_STATE_ID_MAX` is the number of custom interface state contexts for
every stateful interface implemented by this CFU. It must be 0 if every
custom interface implemented by the CFU is stateless. It must be 1+ if
any custom interface implemented by the CFU is stateful. When a leaf CFU
implements multiple stateful custom interfaces, i.e. `CFU_CFU_ID_MAX`>1,
each must be configured with the same number of state contexts.

`CFU_LATENCY` and `CFU_RESET_LATENCY` are specific to CFU-L1 fixed
latency CFUs.  See §<<cfu-l1>>.

[[clocking]]
==== Clock, reset, clock enable

CFU-L0 is combinational. Other feature levels' signaling is (mostly)
synchronous to rising edge (_posedge_) of `clk`.

When the reset input signal `rst` is asserted on posedge `clk`, it
supercedes all other CFU-LI signaling. Any request processing in
progress is abandoned, all internal state is reset, and `req_ready`
and `resp_valid` output signals, if present, are negated. A CFU-L1 CFU
(which does not have a `req_ready` output) must be ready to receive
its first request after no more than its configured `CFU_RESET_LATENCY`
clock cycles following negation of `rst`.

A clock enable input signal `clk_en` facilitates clock gating of a
CFU. When `clk_en` is asserted on posedge `clk`, synchronous elements of
the CFU (i.e., memories, registers, flip-flops) may change. When `clk_en`
is negated on posedge `clk`, no changes may occur to synchronous elements
of the CFU. CFU operation is suspended. Therefore, when negating `clk_en`,
a CFU requester must disregard all CFU output signals, esp. `req_ready`
and `resp_valid`.

[TIP]
====
In the twilight of Moore's Law, energy efficiency is a first order
design concern, and it is a shame to burn power computing routinely
discarded results.
====

[TIP]
====
All modern FPGAs enable simple clock gating via _free_ `clk_en` inputs
on all LUT-cluster D flip-flops.
====

[TIP]
====
If a requester never clock gates a CFU with `clk_en`, it should assert
`clk_en` with a constant `'1`. FPGA and ASIC implementation tools typically
optimize away such signals and their D flip-flop clock enables.
====

[NOTE]
====
Perhaps provide another configuration parameter `CFU_USE_CLK_EN=0/1` to
configurably-ignore `clk_en`. This could simplify conversion of
preexisting RTL function units, sans `clk_en` gating, into new CFUs.
====

[[flow-control]]
==== Request and response valid-ready flow control

CFU-L2, -L3, and -L4 provide CFU request channel synchronous valid-ready
flow control. CFU-L3 and -L4 also provide CFU response channel synchronous
valid-ready flow control.

With synchronous valid-ready flow control, the sender may assert data
and a positive-true data `valid` signal indicating it is ready to send
data. The receiver may assert a positive-true `ready` signal indicating it
is ready to receive data. On posedge `clk`, if both `valid` and `ready` are
asserted, data transfers from sender to receiver; otherwise, no transfer
occurs during that clock cycle.

Once a sender asserts data and asserts data `valid` on posedge `clk`,
it must assert the same data and `valid` on each subsequent posedge `clk`
until the receiver asserts `ready` and the transfer occurs.

A `valid` output must not depend (via combinational logic) upon a `ready`
input. However, a `ready` output may depend upon a `valid` input.

For feature levels that include both request and response flow control,
a requester may not indefinitely negate `resp_ready` in response to a
responder negating `req_ready`.

[TIP]
====
This precludes a potential cyclical wait deadlock in a composed system.
====

==== Request-response ID

CFU-LI feature level 2 or higher include a request-response ID
<<REQ_ID,REQ_ID>>, a `REQ_ID_W` -bit signal used by requesters to
correlate responses received with requests sent. With each request, the
CFU receives the REQ_ID as `req_id`, and later, with each response, the CFU
sends back the same REQ_ID as `resp_id`. For each request/response pair,
the CFU must send the requester the identical request-response ID value
that the requester previously sent to the CFU.

Operation and behavior of a CFU must not depend in any way upon any
`req_id` value received, except to receive it and later to return it
to the requester.

[TIP]
====
An out-of-order completion CPU may send a REQ_ID indicating the
destination register of the request, and rely upon it when the response
eventually returns.
====

[TIP]
====
A system including an intermediary CFU, such as a mux CFU, may be
configured to add additional REQ_ID bits to provide a response return
path.
====

[[error-checking]]
==== Response status / error checking

At any feature level, in response to receiving a CFU request, the CFU
error-checks the request data, performs the request, and outputs the first
(i.e., lowest numbered) `[2:0] resp_status` condition that applies:

.CFU response status values and conditions
[width="100%",cols="23%,7%,70%",options="header",]
|===
|Name |Value |Condition
|`CFU_OK` |0 |no errors occurred processing request
|`CFU_ERROR_CFU` |1 |`req_cfu` is not a CFU_ID implemented by CFU
|`CFU_ERROR_STATE` |2 |`req_state` is not a valid STATE_ID for `req_cfu`
|`CFU_ERROR_FUNC` |3 |`req_func` is not a valid CF_ID for `req_cfu`
|`CFU_ERROR_OP` |4 |request operand(s) or state are a domain error for the custom function
|`CFU_ERROR_CUSTOM` |5 |request causes a custom error (of a serializable custom interface)
|===

When parameter `CPU_CFU_ID_W=0`, `req_cfu` is ignored: no `CFU_ERROR_CFU`
errors.

When parameter `CPU_STATE_ID_W=0`, `req_state` is ignored: no
`CFU_ERROR_STATE` errors.

`STATE_ID=0` is the only valid STATE_ID for the CFU of a stateless
custom interface.

CFU state may change if and only if the response status is one of
`CFU_OK`, `CFU_ERROR_OP`, or `CFU_ERROR_CUSTOM`.

[TIP]
====
When a response status is `CFU_ERROR_CUSTOM`, the CFU should update
the specified state context's custom error status as a side effect of
the request. Otherwise, a CI library may be surprised to observe that the
custom error bit `cfu_status.CU` is set without observing a corresponding
error bit upon retrieving (via `cfu_read_status`) its state context's
error state.
====

In response to receiving `resp_status` of `CFU_ERROR_CFU`,
`CFU_ERROR_STATE`, or `CFU_ERROR_FUNC`, a CPU ignores `resp_data` and
uses zero as the result of the CF instruction.

When a CF instruction writes a destination register, (i.e.,
`custom-0`/`-1` but not `custom-2`), the result of the CF instruction
is written to the register, irrespective of the CFU response status.

[TIP]
====
Can certain errors suppress destination register writes? No: data
dependent writeback cancelation is irregular and unnecessarily complicates
out of order CPUs.
====

[TIP]
====
Together these rules ensure { CFU, state, function } ID errors are
well behaved at the hardware-software interface. By making the CPU
responsible for zeroing such results, each CFU in a system's CFU DAG
need not incur redundant logic and delay to respond `resp_data=0` on
these three errors. For synchronously signaled CFU-LI levels, in an FPGA,
with reset-able flip-flops, a registered `resp_data` input may be zeroed
for negligible cost.
====

[[raw-insn]]
==== Raw instruction

At CFU-LI feature level 2, or higher, CFU requests may be configured
(`CFU_INSN_W=32`) to include the raw instruction word (`req_insn`) of
the CF instruction issued the CFU request, if the request originates
from a CF instruction, or all zeroes otherwise. A CFU may use the raw
instruction data to help perform a custom function, or it may ignore
the raw instruction entirely.

[TIP]
====
The raw instruction complements the <<CF_ID,CF_ID>> (`req_func`)
identifier. CF_ID is the preferred, future proof way to select a custom
function. It is ISA neutral and abstracts the CPU away from CFU, and
potentially reduces verification complexity.
====

[TIP]
====
However, access to the raw CF instruction word can enable additional
use cases. As an example, consider a CFU with a private vector, matrix,
or complex number register file. When this CFU receives a CFU request
including its raw instruction word, it may opt to ignore either or
both of the two integer request operands `req_data0` and `req_data1`,
and instead partially decode the raw instruction word to recover `rs1`
and `rs2` fields, even `rs3` if there are spare CF instruction bits,
to determine which of its CFU register file entries to read. Similarly,
the CFU can decode the raw instruction word to recover an `rd` field
to determine which CFU-private register file entry to write back and
whether to do so.
====

[TIP]
====
This feature is best used with the <<custom-2,`custom-2`>> flex
instruction format which has no `rd` destination register field,
freeing those bits for arbitrary uses.
====

[NOTE]
====
Does raw instruction access merits security threat modeling?  Imagine
adversarial CFUs, snoopily watching the dynamic instruction stream go by,
even when `req_valid` is negated.
====

[NOTE]
====
Half-baked idea (not recommended):
Imagine a dynamic facility by which any arbitrary instruction word, not
just `custom-0`/`-1`/`-2` format instructions, may be a CF instruction,
issued to a CFU.
This might be a table of (mask,pattern) tuples, or a 32-bit
`mcfu_opcodes_mask` CSR bitvector of 5-bit major opcodes, identifying
instructions to divert to the current CFU. Or perhaps, in the hardware
domain, a CPU might frst issue each instruction to the current CFU, and
only execute the instruction in the CPU if the CFU delegates it back to
the CPU.
====

=== CFU-L0 combinational CFU signaling

A combinational CFU, which implements a stateless custom interface,
computes a combinational function of the CFU request, sending a CFU
response after some propagation delay. There is no flow control.

==== CFU-L0 configuration parameters

.CFU-L0 configuration parameters
[width="100%",cols="37%,63%",options="header",]
|===
|*Parameter* |*Description*
|`CFU_VERSION` |CFU-LI version number
|`CFU_CFU_ID_MAX` |number of CFUs at/below this CFU
|===

For `CFU_VERSION` and `CFU_CFU_ID_MAX`, see §<<parameters>>.

==== CFU-L0 signals

.CFU-L0 signals
[width="100%",cols="10%,17%,22%,51%",options="header",]
|===
^|*Dir* |*Port* |*Width Parameter* |*Description*
^|in |`req_valid` | |request valid
^|in |`req_cfu` |`CFU_CFU_ID_W` |request <<CFU_ID,CFU_ID>>: selects the requested CFU
^|in |`req_func` |`CFU_FUNC_ID_W` |request <<CF_ID,CF_ID>>
^|in |`req_data0` |`CFU_DATA_W` |request operand data 0
^|in |`req_data1` |`CFU_DATA_W` |request operand data 1
^|out |`resp_status` |`CFU_STATUS_W` |response status
^|out |`resp_data` |`CFU_DATA_W` |response data
|===

CFU-L0 signaling is asynchronous. CFU outputs are pure combinational functions of CFU inputs.

[TIP]
====
CFU-L0 has no `resp_valid` signal because it would just reflect `req_valid`.
====

==== CFU-L0 signaling protocol

Protocol:

[arabic]
. Request transfer
[loweralpha]
.. Requester asserts CFU request signals `req_*` and asserts `req_valid`.
.. CFU asynchronously receives CFU request.
. Response transfer
[loweralpha]
.. CFU performs steps 1, 2, 4, and 6 of response status / error checking per §<<error-checking>>, and asserts `resp_status`.
.. CFU asserts `resp_data`, a combinational custom function of the operands.
.. Requester asynchronously receives CFU response.

As a CFU-L0 CFU is combinational, its delay folds into to the path timing
analysis of its requester.

==== CFU-L0 example

[[cfu-l0-wave]]
.Example CFU-L0 signaling protocol waveform
[wavedrom,target="cfu-l0",svg]
....
{signal: [
['Request',
{  name: 'req_valid',   wave: '0101.0' },
{  name: 'req_cfu',     wave: 'x3x45x', data: 'u0 u0 u0 u0'  },
{  name: 'req_func',    wave: 'x3x45x', data: 'f0 f1 f2 f3' },
{  name: 'req_data0',   wave: 'x3x45x', data: 'a0 a1 a2 a3' },
{  name: 'req_data1',   wave: 'x3x45x', data: 'b0 b1 b2 b3' },
],
['Resp.',
{  name: 'resp_status',  wave: 'xx3x45x', data: 'ok err1 ok ok', phase: 1.5  },
{  name: 'resp_data',   wave: 'xx3x45x', data: 'res0 0 res2 res3', phase: 1.5 },
]
], config: { hscale: 2 },
}
....

<<cfu-l0-wave>> is an example waveform for three CFU-L0 requests
and responses, arising from executing CF instructions `f0(a0,b0)`,
`f1(a1,b1)`, and `f2(a2,b2)`. All three instructions issue to the same
CFU `u0`. `f1` incurs an error.

=== CFU-L1 fixed latency CFU signaling

Each cycle, a fixed latency CFU computes a function of the CFU request
*and the specified state context, if any, updating the context*, sending
a CFU response after a configured *fixed non-negative number of clock
cycles*. With an initiation interval of II=1/cycle, there is no flow
control of requests or responses.

Lacking request flow control, if a CFU-L1 CFU is configured with multiple
requesters, requesters must not send multiple simultaneous requests.

==== CFU-L1 configuration parameters

.CFU-L1 configuration parameters
[width="100%",cols="25%,75%",options="header",]
|===
|*Parameter* |*Description*
|`CFU_VERSION` |CFU-LI version number
|`CFU_CFU_ID_MAX` |number of CFUs at/below this CFU
|`CFU_STATE_ID_MAX` |number of custom interface state contexts
|`CFU_LATENCY` |latency (clock cycles) from a request to its response
|`CFU_RESET_LATENCY` |minimum latency (clock cycles) from negation of reset to first request
|===

For `CFU_VERSION`, `CFU_CFU_ID_MAX`, and `CFU_STATE_ID_MAX`, see §<<parameters>>.

`CFU_LATENCY`, specific to CFU-L1, configures the CFU latency, which
is the number of clock cycles from receiving a request to sending a
response, of every custom function implemented by the CFU. `CFU_LATENCY=0`
configures the CFU to respond to the request in the same clock cycle.

A CFI-L1 CFU with `CFU_LATENCY=0` resembles a CFU-L0 combinational
CFU, except it may implement a stateful custom interface. Example: an
extended precision arithmetic CFU which implements `add_save_carry` and
`add_with_carry_save_carry` CF instructions. Like an ALU, this has zero
cycle latency, but supports additional state context(s), each with a
carry bit.

`CFU_RESET_LATENCY`, specific to CFU-L1, configures the CFU reset latency,
which is the minimum number of clock cycles from negation of `rst`
to first assertion of `req_valid`. `CFU_RESET_LATENCY=0` configures
the CFU to be ready for a CFU request in the same cycle that `rst`
is first negated.

==== CFU-L1 signals

.CFU-L1 signals
[width="100%",cols="11%,25%,28%,36%",options="header",]
|===
^|*Dir* |*Port* |*Width Parameter* |*Description*
^|in |`clk` | |clock
^|in |`rst` | |reset
^|in |`clk_en` | |clock enable
^|in |`req_valid` | |request valid
^|in |`req_cfu` |`CFU_CFU_ID_W` |request <<CFU_ID,CFU_ID>>
^|in |`req_state` |`CFU_STATE_ID_W` |request <<STATE_ID,STATE_ID>>
^|in |`req_func` |`CFU_FUNC_ID_W` |request <<CF_ID,CF_ID>>
^|in |`req_data0` |`CFU_DATA_W` |request operand data 0
^|in |`req_data1` |`CFU_DATA_W` |request operand data 1
^|out |`resp_valid` | |response valid
^|out |`resp_status` |`CFU_STATUS_W` |response status
^|out |`resp_data` |`CFU_DATA_W` |response data
|===

==== CFU-L1 signaling protocol

CFU-L1 is (mostly) synchronous to posedge `clk` when `CFU_LATENCY>0`. See
§<<clocking>>.

Protocol:

[arabic]
. Request transfer.
[loweralpha]
.. Requester asserts CFU request signals `req_*` and asserts `req_valid`.
.. `CFU_LATENCY=0`: CFU receives CFU request asynchronously. +
`CFU_LATENCY>0`: CFU receives CFU request on posedge `clk`.
. Custom function execution.
[loweralpha]
.. CFU performs response status / error checking per §<<error-checking>>.
.. CFU performs a custom function of the operands and the selected state context.
.. CFU may update the selected state context, logically prior to any updates from subsequent requests.
. Response transfer.
[loweralpha]
.. `CFU_LATENCY=0`:
[lowerroman]
... CFU asserts CFU response signals `resp_valid`, `resp_status`, and `resp_data` asynchronously.
... Requester receives CFU response asynchronously.
.. `CFU_LATENCY>0`:
[lowerroman]
... After (`CFU_LATENCY-1`) cycles, CFU asserts `resp_valid`, `resp_status`, and `resp_data`.
... Requester receives CFU response on posedge `clk`.

==== CFU-L1 example

[[cfu-l1-wave]]
.Example CFU-L1 signaling protocol waveform (`CFU_LATENCY=2`, `CFU_RESET_LATENCY=0`)
[wavedrom,target="cfu-l1",svg]
....
{signal: [
{    name: 'clk',         wave: 'P......|....'},
{    name: 'rst',         wave: '10.....|....'},
{    name: 'clk_en',      wave: '01....0|1...'},
['Request',
{  name: 'req_valid',   wave: '01.0.1.|.0..' },
{  name: 'req_cfu',     wave: 'x34x.56|.x..', data: 'u0 u0 u0 u0' },
{  name: 'req_state',   wave: 'x34x.56|.x..', data: 's0 s0 s2 s2'  },
{  name: 'req_func',    wave: 'x34x.56|.x..', data: 'f0 f1 f2 f3' },
{  name: 'req_data0',   wave: 'x34x.56|.x..', data: 'a0 a1 a2 a3' },
{  name: 'req_data1',   wave: 'x34x.56|.x..', data: 'b0 b1 b2 b3' },
],
['Response',
{  name: 'resp_valid',  wave: '0..1.0.|.1.0' },
{  name: 'resp_status',  wave: 'x..34x.|.56x', data: 'ok err1 ok ok' },
{  name: 'resp_data',   wave: 'x..34x.|.56x', data: 'res0 0 res2 res3' },
]],
head:{
tick:'0 1 2 3 4 5 6 7 20 21 22 23 24 25 '
},
foot:{
tock:'0 1 2 3 4 5 6 7 20 21 22 23 24 25'
},}
....

<<cfu-l1-wave>> is an example waveform for four CFU-L1 CFU requests and
responses, arising from executing four CF instructions `f0`-`f3`. Since
`CFU_RESET_LATENCY=0`, the CFU is ready for request `f0` in cycle 1, the
same cycle `rst` is negated. With `CFU_LATENCY=2`, each response occurs 2
(enabled) clock cycles after each request is received. Each instruction
issues a CFU request to the same CFU `u0`. Instructions `f0` and `f1` use
state context s0; `f2` and `f3` use state context `s2`. Request `f1` results
in an error response. With `clk_en` negated in cycles 6-19, the CFU is
frozen until cycle 20, when it finally receives the `f3` request. The `f2`
response, otherwise due in cycle 7, is also delayed, until cycle 21.

=== CFU-L2 variable latency CFU signaling

A variable latency CFU computes a function of the CFU request and the
specified state context, if any, updating the context, sending a CFU
response, *in order, in a later clock cycle*. There is *request flow
control*.

When the requester is a CPU, use of CFU-L2 means the CPU must be ready to
accept a response from the CFU on any cycle. This simplifies the design
of the CFU but may complicate the design of the CPU pipeline and its
register file write arbitration logic.

==== CFU-L2 configuration parameters

.CFU-L2 configuration parameters
[width="100%",cols="34%,66%",options="header",]
|===
|*Parameter* |*Description*
|`CFU_VERSION` |CFU-LI version number
|`CFU_CFU_ID_MAX` |number of CFUs at/below this CFU
|`CFU_STATE_ID_MAX` |number of custom interface state contexts
|===

For `CFU_VERSION`, `CFU_CFU_ID_MAX`, and `CFU_STATE_ID_MAX`, see §<<parameters>>.

==== CFU-L2 signals

.CFU-L2 signals

[width="100%",cols="11%,24%,27%,38%",options="header",]
|===
^|*Dir* |*Port* |*Width Parameter* |*Description*
^|in |`clk` | |clock
^|in |`rst` | |reset
^|in |`clk_en` | |clock enable
^|in |`req_valid` | |request valid
^|out |`req_ready` | |request ready
^|in |`req_id` |`CFU_REQ_ID_W` |request <<REQ_ID,REQ_ID>>
^|in |`req_cfu` |`CFU_CFU_ID_W` |request <<CFU_ID,CFU_ID>>
^|in |`req_state` |`CFU_STATE_ID_W` |request <<STATE_ID,STATE_ID>>
^|in |`req_insn` |`CFU_INSN_W` |request raw instruction
^|in |`req_func` |`CFU_FUNC_ID_W` |request <<CF_ID,CF_ID>>
^|in |`req_data0` |`CFU_DATA_W` |request operand data 0
^|in |`req_data1` |`CFU_DATA_W` |request operand data 1
^|out |`resp_valid` | |response valid
^|out |`resp_id` |`CFU_REQ_ID_W` |response ID
^|out |`resp_status` |`CFU_STATUS_W` |response status
^|out |`resp_data` |`CFU_DATA_W` |response data
|===

==== CFU-L2 signaling protocol

CFU-L2 is synchronous to posedge `clk`. See §<<clocking>>. CFU-L2
includes a request-response ID. See §<<error-checking>>. CFU-L2 includes
the request's raw instruction. See §<<raw-insn>>.

Protocol:

[arabic]
. Request transfer.
[loweralpha]
.. Requester asserts CFU request signals `req_*` and asserts `req_valid`.
.. Responder may assert `req_ready`.
.. CFU receives CFU request on posedge `clk` when `req_valid` and `req_ready` are both asserted, per §<<flow-control>>.
. Custom function execution.
[loweralpha]
.. CFU performs response status / error checking per §<<error-checking>>.
.. CFU performs a custom function of the operands and the selected state context.
.. CFU may update the selected state context, logically prior to any updates from subsequent requests.
. Response transfer
[loweralpha]
.. Prior to issuing responses from subsequent requests (i.e., in order of requests) CFU asserts `resp_id`, `resp_status`, `resp_data` and asserts `resp_valid`.
.. Requester receives CFU response on posedge `clk`.

==== CFU-L2 example

[[cfu-l2-wave]]
.Example CFU-L2 signaling protocol waveform
[wavedrom,target="cfu-l2",svg]
....
{signal: [
{    name: 'clk',         wave: 'P...........'},
{    name: 'rst',         wave: '10..........'},
{    name: 'clk_en',      wave: '01..........'},
['Request',
{  name: 'req_valid',   wave: '0.1..01.0...' },
{  name: 'req_ready',   wave: '0.1010.1....'  },
{  name: 'req_id',      wave: 'x.34.x5.x...', data: 'id0 id1 id2'  },
{  name: 'req_cfu',     wave: 'x.34.x5.x...', data: 'u0 u0 u0'  },
{  name: 'req_state',   wave: 'x.34.x5.x...', data: 's0 s0 s2'  },
{  name: 'req_func',    wave: 'x.34.x5.x...', data: 'f0 f1 f2'  },
{  name: 'req_data0',   wave: 'x.34.x5.x...', data: 'a0 a1 a2'  },
{  name: 'req_data1',   wave: 'x.34.x5.x...', data: 'b0 b1 b2'  },
],
['Response',
{  name: 'resp_valid',  wave: '0..10.10..10' },
{  name: 'resp_id',     wave: 'x..3x.4x..5x', data: 'id0 id1 id2'  },
{  name: 'resp_status',  wave: 'x..3x.4x..5x', data: 'ok err1 ok' },
{  name: 'resp_data',   wave: 'x..3x.4x..5x', data: 'res0 0 res2'  },
]
],
head:{
tick:0
},
foot:{
tock:0
}
}
....

<<cfu-l2-wave>> is an example waveform for three CFU-L2 CFU requests and
responses, arising from executing three CF instructions `f0`-`f2`. (Assume
`CFU_INSN_W=0`, no `req_insn`.) Each instruction issues a CFU request
to the same CFU `u0`. Instructions `f0` and `f1` use state context `s0`;
`f2` uses state context `s2`. The CFU receives request `f0`, with `req_id`
`id0`, in cycle 2 and responds, with same `resp_id` `id0`, in cycle 3, a
latency of 1 cycle. Requester asserts request `f1` in cycle 3, but it is
not received by the CFU until it reasserts `req_ready` in cycle 4. The
CFU responds to `f1` in cycle 6, with an error response, a latency of 2
cycles. Requester asserts request `f2` in cycle 6, but it is not received
by the CFU until it reasserts `req_ready` in cycle 7. The CFU responds to
`f2` in cycle 10, a latency of 3 cycles.

=== CFU-L3 elastic CFU signaling

An elastic CFU computes a function of a CFU request and the specified
state context, if any, updating the context, sending a CFU response,
in order, in a later clock cycle. There is *request and response flow
control* so the CFU can suspend receiving requests and the requester
can suspend receiving responses.

[TIP]
====
When the requester is a CPU, use of CFU-L3 allows the CPU to delay receipt
of a CFU response. This affords the CPU pipeline greater flexibility
to dynamically prioritize other units' accesses to register file write
port(s). Conversely, CFU-L3 may complicate design of the CFU, which may
respond to negated `resp_ready` by buffering the response in an output
FIFO or by applying back pressure through its processing pipeline,
or negate `req_ready` to delay receipt of new requests.
====

==== CFU-L3 configuration parameters

.CFU-L3 configuration parameters
[width="100%",cols="34%,66%",options="header",]
|===
|*Parameter* |*Description*
|`CFU_VERSION` |CFU-LI version number
|`CFU_CFU_ID_MAX` |number of CFUs at/below this CFU
|`CFU_STATE_ID_MAX` |number of custom interface state contexts
|===

For `CFU_VERSION`, `CFU_CFU_ID_MAX`, and `CFU_STATE_ID_MAX`, see §<<parameters>>.

==== CFU-L3 signals

.CFU-L3 signals
[width="100%",cols="11%,24%,27%,38%",options="header",]
|===
^|*Dir* |*Port* |*Width Parameter* |*Description*
^|in |`clk` | |clock
^|in |`rst` | |reset
^|in |`clk_en` | |clock enable
^|in |`req_valid` | |request valid
^|out |`req_ready` | |request ready
^|in |`req_id` |`CFU_REQ_ID_W` |request <<REQ_ID,REQ_ID>>
^|in |`req_cfu` |`CFU_CFU_ID_W` |request <<CFU_ID,CFU_ID>>
^|in |`req_state` |`CFU_STATE_ID_W` |request <<STATE_ID,STATE_ID>>
^|in |`req_insn` |`CFU_INSN_W` |request raw instruction
^|in |`req_func` |`CFU_FUNC_ID_W` |request <<CF_ID,CF_ID>>
^|in |`req_data0` |`CFU_DATA_W` |request operand data 0
^|in |`req_data1` |`CFU_DATA_W` |request operand data 1
^|out |`resp_valid` | |response valid
^|in |`resp_ready` | |response ready
^|out |`resp_id` |`CFU_REQ_ID_W` |response ID
^|out |`resp_status` |`CFU_STATUS_W` |response status
^|out |`resp_data` |`CFU_DATA_W` |response data
|===

==== CFU-L3 signaling protocol

CFU-L3 is synchronous to posedge `clk`. See §<<clocking>>. CFU-L3
includes a request-response ID. See §<<error-checking>>. CFU-L3 includes
the request's raw instruction. See §<<raw-insn>>.

Protocol:

[arabic]
. Request transfer.
[loweralpha]
.. Requester asserts CFU request signals `req_*` and asserts `req_valid`.
.. Responder may assert `req_ready`.
.. CFU receives CFU request on posedge `clk` when `req_valid` and `req_ready` are both asserted, per §<<flow-control>>.
. Custom function execution.
[loweralpha]
.. CFU performs response status / error checking per §<<error-checking>>.
.. CFU performs a custom function of the operands and the selected state context.
.. CFU may update the selected state context, logically prior to any updates from subsequent requests.
. Response transfer.
[loweralpha]
.. Prior to issuing responses from subsequent requests (i.e., in order of requests) CFU asserts `resp_id`, `resp_status`, `resp_data` and asserts `resp_valid`.
.. Requester may assert `resp_ready`.
.. Requester receives CFU response on posedge `clk` when `resp_valid` and `resp_ready` are both asserted, per §<<flow-control>>.

==== CFU-L3 example

<<cfu-l3-wave>> is an example waveform for four CFU-L3 CFU requests and
responses, arising from executing four CF instructions `f0`-`f3`. (Assume
`CFU_INSN_W=0`, no `req_insn`.) Each instruction issues a CFU request
to the same CFU `u0`. Instructions `f0` and `f1` use state context `s0`;
`f2` and `f3` use state context `s2`.

[[cfu-l3-wave]]
.Example CFU-L3 signaling protocol waveform
[wavedrom,target="cfu-l3",svg]
....
{signal: [
{    name: 'clk',         wave: 'P........|...'},
{    name: 'rst',         wave: '10.......|...'},
{    name: 'clk_en',      wave: '01.......|...'},
['Request',
{  name: 'req_valid',   wave: '0.1..01.0|10.' },
{  name: 'req_ready',   wave: '0.1010.1.|...'  },
{  name: 'req_id',      wave: 'x.34.x5.x|6x.', data: 'id0 id1 id2 id3' },
{  name: 'req_cfu',     wave: 'x.34.x5.x|6x.', data: 'u0 u0 u0 u0' },
{  name: 'req_state',   wave: 'x.34.x5.x|6x.', data: 's0 s0 s2 s2'   },
{  name: 'req_func',    wave: 'x.34.x5.x|6x.', data: 'f0 f1 f2 f3' },
{  name: 'req_data0',   wave: 'x.34.x5.x|6x.', data: 'a0 a1 a2 a3' },
{  name: 'req_data1',   wave: 'x.34.x5.x|6x.', data: 'b0 b1 b2 b3' },
],
['Response',
{  name: 'resp_valid',  wave: '0..10.1.0|1.0' },
{  name: 'resp_ready',  wave: '0.1.0..1.|...' },
{  name: 'resp_id',     wave: 'x..3x.4.x|56x', data: 'id0 id1 id2 id3'  },
{  name: 'resp_status',  wave: 'x..3x.4.x|56x', data: 'ok err1 ok ok' },
{  name: 'resp_data',   wave: 'x..3x.4.x|56x', data: 'res0 res1 res2 res3' },
]
],
head:{
tick:'0 1 2 3 4 5 6 7 8 20 21 22 23 24 25'
},
foot:{
tock:'0 1 2 3 4 5 6 7 8 20 21 22 23 24'
},}
....

The CFU receives request `f0`, with `req_id` `id0`, in cycle 2 and
responds, with `resp_id` `id0`, in cycle 3.

Requester asserts request `f1` in cycle 3, but it is not received by
the CFU until it asserts `req_ready` in cycle 4. The CFU sends the `f1`
response in cycle 6, an error response, a latency of 2 cycles. Requester
asserts `resp_ready` and receives the response in cycle 7.

Requester asserts request `f2` in cycle 6, but it is not received by
the CFU until it asserts `req_ready` in cycle 7. The CFU responds to
`f2` in cycle 21, a latency of 14 cycles.

Requester asserts request `f3` in cycle 21, and the CFU responds in
cycle 22.

=== CFU-L4 reordering CFU signaling

A reordering CFU computes a function of the CFU request and the specified
state context, if any, updating the context, and sending a CFU response
in a later clock cycle. *Responses for requests with the same context
are sent in order, otherwise may be sent out of order*. There is request
and response flow control.

[TIP]
====
This CFU-LI feature level is motivated by past experience building
floating point CFUs. Different functions, e.g., comparison, conversion,
multiplication, addition, division, and square root, exhibit a wide range
of latencies. Some functions, e.g. addition and multiplication, may be
pipelined and afford an initiation interval II=1/cycle, while others,
e.g. division and square root, may be variable latency and perform one
request at a time.

Particularly when a custom interface is stateless and when the requester
(e.g., an in-order-issue/out-of-order completion CPU) tolerates out
of order responses, response reordering can improve performance and
simplify CFU logic by reducing average CFU latency, enabling greater
CFU parallelism, and reducing request blocking and response queueing.
====

[TIP]
====
When a custom interface is stateful, response reordering cannot occur
for any sequence of requests with the same state context, to ensure
identical response data and program behavior over time and over different
CFU implementations of the same custom interface.
====

==== CFU-L4 configuration parameters

.CFU-L4 configuration parameters
[width="100%",cols="34%,66%",options="header",]
|===
|*Parameter* |*Description*
|`CFU_VERSION` |CFU-LI version number
|`CFU_CFU_ID_MAX` |number of CFUs at/below this CFU
|`CFU_STATE_ID_MAX` |number of custom interface state contexts
|===

For `CFU_VERSION`, `CFU_CFU_ID_MAX`, and `CFU_STATE_ID_MAX`, see
§<<parameters>>.

==== CFU-L4 signals

.CFU-L4 signals
[width="100%",cols="11%,24%,27%,38%",options="header",]
|===
^|*Dir* |*Port* |*Width Parameter* |*Description*
^|in |`clk` | |clock
^|in |`rst` | |reset
^|in |`clk_en` | |clock enable
^|in |`req_valid` | |request valid
^|out |`req_ready` | |request ready
^|in |`req_id` |`CFU_REQ_ID_W` |request <<REQ_ID,REQ_ID>>
^|in |`req_cfu` |`CFU_CFU_ID_W` |request <<CFU_ID,CFU_ID>>
^|in |`req_state` |`CFU_STATE_ID_W` |request <<STATE_ID,STATE_ID>>
^|in |`req_insn` |`CFU_INSN_W` |request raw instruction
^|in |`req_func` |`CFU_FUNC_ID_W` |request <<CF_ID,CF_ID>>
^|in |`req_data0` |`CFU_DATA_W` |request operand data 0
^|in |`req_data1` |`CFU_DATA_W` |request operand data 1
^|out |`resp_valid` | |response valid
^|in |`resp_ready` | |response ready
^|out |`resp_id` |`CFU_REQ_ID_W` |response ID
^|out |`resp_status` |`CFU_STATUS_W` |response status
^|out |`resp_data` |`CFU_DATA_W` |response data
|===

==== CFU-L4 signaling protocol

CFU-L4 is synchronous to posedge `clk`. See §<<clocking>>. CFU-L4
includes a request-response ID. See §<<error-checking>>. CFU-L4 includes
the request's raw instruction. See §<<raw-insn>>.

Protocol:

[arabic]
. Request transfer.
[loweralpha]
.. Requester asserts CFU request signals `req_*` and asserts `req_valid`.
.. Responder may assert `req_ready`.
.. CFU receives CFU request on posedge `clk` when `req_valid` and `req_ready` are both asserted, per §<<flow-control>>
. Custom function execution.
[loweralpha]
.. CFU performs response status / error checking per §<<error-checking>>.
.. CFU performs a custom function of the operands and the selected state context.
.. CFU may update the selected state context, logically prior to any updates _to the same state context_ from subsequent requests.
. Response transfer.
[loweralpha]
.. Prior to issuing responses from subsequent requests _to the same state context_ (i.e., in order of requests to the same state context) CFU asserts `resp_id`, `resp_status`, `resp_data` and asserts `resp_valid`.
.. Requester may assert `resp_ready`.
.. Requester receives CFU response on posedge `clk` when `resp_valid` and `resp_ready` are both asserted, per §<<flow-control>>.

==== CFU-L4 example

<<cfu-l4-wave>> is an example waveform for four CFU-L4 CFU requests,
illustrating two different valid out-of-order response sequences, arising
from executing four CF instructions `f0`-`f3`. (Assume `CFU_INSN_W=0`,
no `req_insn`.) Each instruction issues a CFU request to the same CFU
`u0`, but with various state contexts `s0`, `s1`, `s0` (again), and
`s3`. This constrains the CFU to respond to request `f0` with state
`s0`, before responding to subsequent request `f2` for state `s0`.

[[cfu-l4-wave]]
.Example CFU-L4 signaling protocol waveform, with two of the possible response orderings
[wavedrom,target="cfu-l4",svg]
....
{signal: [
{    name: 'clk',         wave: 'P..........'},
{    name: 'rst',         wave: '10.........'},
{    name: 'clk_en',      wave: '01.........'},
['Request',
{  name: 'req_valid',   wave: '0.1...0....' },
{  name: 'req_ready',   wave: '0.1........'  },
{  name: 'req_id',      wave: 'x.3456x....', data: 'id0 id1 id2 id3' },
{  name: 'req_cfu',     wave: 'x.3456x....', data: 'u0 u0 u0 u0' },
{  name: 'req_state',   wave: 'x.3456x....', data: 's0 s1 *s0 s3'   },
{  name: 'req_func',    wave: 'x.3456x....', data: 'f0 f1 f2 f3' },
{  name: 'req_data0',   wave: 'x.3456x....', data: 'a0 a1 a2 a3'  },
{  name: 'req_data1',   wave: 'x.3456x....', data: 'b0 b1 b2 b3'  },
],
['Response',
{  name: 'resp_valid',  wave: '0...101.010' },
{  name: 'resp_ready',  wave: '0.1........' },
{  name: 'resp_id',     wave: 'x...4x63x5x', data: 'id1 id3 id0 id2'   },
{  name: 'resp_status',  wave: 'x...4x63x5x', data: 'ok ok ok ok'  },
{  name: 'resp_data',   wave: 'x...4x63x5x', data: 'res1 res3 res0 res2'   },
],
{},
['Another Ordering',
{  name: 'resp_valid',  wave: '0.....1...0' },
{  name: 'resp_ready',  wave: '0.1........' },
{  name: 'resp_id',     wave: 'x.....6354x', data: 'id3 id0 id2 id1'   },
{  name: 'resp_status',  wave: 'x.....6354x', data: 'ok ok ok ok'  },
{  name: 'resp_data',   wave: 'x.....6354x', data: 'res3 res0 res2 res1'   },
]
],
head:{ tick:'0' },
foot:{ tock:'0' },
}
....

In the first example response, with signals labeled _Response_, the
CFU receives requests (`f0`, `f1`, `f2`, `f3`) but responds in order
(`f1`, `f3`, `f0`, `f2`). In the second example response, with signals
labeled _Another Ordering_, the CFU responds in order (`f3`, `f0`,
`f2`, `f1`). Bother orderings are valid because they preserve the order
`f0`<`f2` caused by these two CFU requests using the same state `s0`.

=== CFU feature level adapters

A CFU feature level adapter is an intermediary CFU that receives requests
and sends responses at one CFU-LI feature level and adapts them for and
forwards them to a subordinate CFU at a lower CFU-LI feature level.

CFU-LI includes a set of configurable adapters to raise any CFU to any
higher feature level, easing composition:

* `Cvt01`: raise L0 to L1: add configurable latency pipelining
* `Cvt02`, `Cvt12`: raise L0 or L1 to L2: add request flow control (always accepts requests)
* `Cvt03`, `Cvt13`, `Cvt23`: raise L0-L2 to L3: add response flow control (may suspend requests)

Any L3 CFU, with in-order responses, may be directly used as an L4 CFU,
because response reordering is optional.

==== `Cvt01`: raise CFU-L0 to CFU-L1

A `Cvt01` adapter CFU implements CFU-L1, including its configuration
parameters (§<<_cfu_l1_configuration_parameters>>), adapting L1 requests
to and responses from a subordinate combinational L0 CFU.

When `CFU_LATENCY=0`, the adapter's request/response channels are directly
coupled to the subordinate CFU request/response channels. Otherwise,
these channels I/Os are registered and pipelined, with a total latency of
`CFU_LATENCY` cycles.

[TIP]
====
Automatic pipeline retiming may _slice_ the combinational logic cone
into several pipeline stages, achieving higher frequency operation.
====

==== `Cvt02`: raise CFU-L0 to CFU-L2

A `Cvt02` adapter CFU implements CFU-L2, including its configuration
parameters (§<<_cfu_l2_configuration_parameters>>), adapting L2 requests
to and responses from a subordinate combinational L0 CFU. It implements
request (non) flow control by permanently asserting `req_ready`. For
each request received, it sends a response, asserting `resp_valid`,
`resp_id`, `resp_status`, and `resp_data` on next posedge `clk`.

==== `Cvt12`: raise CFU-L1 to CFU-L2

A `Cvt12` adapter CFU implements CFU-L2, including its configuration
parameters (§<<_cfu_l2_configuration_parameters>>), plus `CFU_LATENCY`
(§<<_cfu_l1_configuration_parameters>>), adapting L2 requests to and
responses from a subordinate fixed latency L1 CFU. The `CFU_LATENCY`
parameter specifies the latency of the _subordinate CFU_.  The adapter
implements request (non) flow control by permanently asserting
`req_ready`. For each request received, it sends a response, including the
FIFO output's delayed `req_id`, augmenting the current subordinate CFU's
`resp_valid`, `resp_status`, and `resp_data`.

When `CFU_LATENCY=0`, the subordinate CFU response must be registered,
so the adapter's response latency is one cycle.

==== `Cvt03`: raise CFU-L0 to CFU-L3

A `Cvt03` adapter CFU implements CFU-L3, including its configuration
parameters (§<<_cfu_l3_configuration_parameters>>), adapting L3 requests
to and responses from a subordinate combinational L0 CFU. The adapter
has a fixed latency of one cycle -- a response is sent one cycle after
a request is received. The `resp_id` output is just `req_id` delayed
one cycle.

[TIP]
====
To avoid arbitrary CFU response queuing, yet keep signaling simple and
frugal, the `Cvt03` adapter might negate `req_ready` on any cycle that it
has a valid response waiting (asserting `resp_valid`) and the requester
negates `resp_ready`.
====

==== `Cvt13`: raise CFU-L1 to CFU-L3

A `Cvt13` adapter CFU implements CFU-L3, including its configuration
parameters (§<<_cfu_l3_configuration_parameters>>), plus `CFU_LATENCY`
(§<<_cfu_l1_configuration_parameters>>), adapting L3 requests to and
responses from a subordinate fixed latency L1 CFU.

The `CFU_LATENCY` parameter, which specifies the latency of the
_subordinate L1 CFU_, typically configures the depth of a response
FIFO -- an entire response stream must be buffered when the requester,
having just issued `CFU_LATENCY` of requests to the L1 CFU, negates
`resp_ready` through as many clock cycles. Eventually, with response
transfers paused, the response FIFO fills and the adapter CFU negates
`req_ready`.

When `CFU_LATENCY=0`, the subordinate CFU response must be registered
and therefore the adapter's response latency is at least one cycle.

==== `Cvt23`: raise CFU-L2 to CFU-L3

A `Cvt23` adapter CFU implements CFU-L3, including its configuration
parameters (§<<_cfu_l3_configuration_parameters>>), adapting L3
requests to and responses from a subordinate variable latency L2 CFU.

[TIP]
====
In one implementation, sans response FIFO queueing, the adapter negates
`req_ready` on any cycle that it has a valid response waiting (asserting
`resp_valid`) and the requester negates `resp_ready`.
====

[[cpus]]
=== CFU-LI-compliant CPUs

A CFU-LI-compliant CPU implements RISC-V RV-I -Zicsr *-Zicfu* instruction
set, sends CFU requests upon issuing CF instructions, and writes a
destination register and CFU status CSR in response to CFU responses.

==== CPUs and CFU-LI feature levels

CPUs, as CFU requesters, use specific CFU-LI feature levels.

[TIP]
====
An austere single-cycle CPU might use CFU-L0 with a combinational CFU
(only).

A pipelined in-order CPU might use CFU-L1 with a fixed latency CFU
configured for (e.g.) 2 cycles latency. It might also use CFU-L2 with
a variable latency CFU, stalling in WB-stage (writeback) if awaiting a
slow CFU response.

An out-of-order completion CPU might use a CFU-L2 variable latency CFU
or a -L3 elastic CFU, the latter if its WB-stage register file write
arbiter cannot always accept a CFU response writeback on any cycle.

An OoO completion CPU, that handles reordered CFU responses, might use
a CFU-L4 reordering CFU.
====

A CPU has one or more sets of CFU request and response ports. For each
such set, a CPU may send zero or one CFU request per cycle and receive
zero or one CFU response per cycle.

[TIP]
====
Most CPUs send up to one request and receive up to one response. However,
a CFU-LI compliant superscalar CPU might send multiple CFU requests
and receive multiple CFU responses, to multiple CFUs of the same, or
different, CFU-LI feature levels, in parallel, in the same cycle.
====

=== Example: CFU signaling in a composed system

Consider <<mux22>>, a system composed from two single-hart CPUs, two
stateful CFUs, and a 2-input, 2-output Mux CFU. Fixed latency CFU~0~
implements CFU-L1, configured with `CFU_LATENCY=1`. The CPUs, CFU~1~,
and `Mux22` use/implement CFU-L2. `Cvt12`, a CFU level converter, up-converts
CF0~0~ from CFU-L1 to CFU-L2.

[[mux22]]
.CFU-L2 system, with two CPUs, mux CFU, converter CFU, CFU~0~ (L1), and CFU~1~ (L2)
image::cfu-mux22.png[image,width=400]

With one hart per CPU, the custom interfaces' CFUs are configured
with two state contexts each (<2>).

Both CPU~0~ and CPU~1~ are configured to issue CF instructions mapping
CI_ID~0~ -> CFU_ID=0 -> CFU~0~ and CI_ID~1~ -> CFU_ID=1 -> CFU~1~.

The exemplary 2x2 Mux CFU is frugal, if low frequency, while sustaining
one cycle initiation interval transfers of requests and responses. It
multiplexes downstream request transfers and upstream response
transfers. In both directions, the mux consists of input ports (not
registered), output port registers, an approximately fair output port
arbiter, and a 2x2 channel crossbar. Each cycle, the mux determines
which output ports are _available_ (i.e., are empty, or will transfer
(valid and ready) this cycle) and which valid inputs are _eligible_
to transfer, then asserts ready, and transfers, some eligible inputs to
available output ports, based upon a rotating priority order.

A _request_ input port is eligible to transfer if it is valid and if
the target `req_cfu` CFU_ID is the same as the last request, or if there
are no pending responses for this port. This ensures that responses for
requests, routed to different CFUs with different latencies, are always
returned in order to the requester, as required by CFU-L2.

Downstream request routing is per the request inputs' `req_cfu` elements:
CFU_ID=0 routes to the first output port and CFU_ID=1 routes to the
second output port. The mux itself responds to requests with invalid
CFU_IDs with a `CFU_ERROR_CFU` response.

For upstream response routing, the system is configured so that the
`CFU_REQ_ID_W` of each CFU downstream of the 2x2 mux CFU also includes
space to record the mux's requester port ID bit. This is added to each
request's `req_id` by the mux, returned from the CFU to the mux in each
`resp_id`, then removed by the mux and used in response routing to return
the response to the correct requester port.

In this example, assume each CPU decouples issue and commit using
a scoreboarded register file enabling arbitrary interface unit
latencies. Each CPU runs the same code (<<cim3>>):

[arabic]
. Write `mcfu_selector` for CFU_ID=0 and STATE_ID=__HART_ID__, issue two CF instructions to CFU~0~;
. Write `mcfu_selector` for CFU_ID=1 and STATE_ID=__HART_ID__, issue two CF instructions to CFU~1~;
. Write `mcfu_selector` for CFU_ID=0 and STATE_ID=__HART_ID__, issue one CF instruction to CFU~0~.

[[cim3]]
.Issue stateful CF instructions `f0` and `f1` to CFU~0~, `f2` and `f3` to CFU~1~, and `f4` to CFU~0~ again.
[source,asm]
....
csrw mcfu_selector,x20  ; select CFU_ID=0 and STATE_ID=HART_ID
cfu_reg 0,x3,x1,x2      ; u0.f0
cfu_reg 1,x6,x5,x4      ; u0.f1

csrw mcfu_selector,x21  ; select CFU_ID=1 and STATE_ID=HART_ID
cfu_reg 2,x9,x7,x8      ; u1.f2
cfu_reg 3,x12,x11,x10   ; u1.f3

csrw mcfu_selector,x20  ; select CFU_ID=0 and STATE_ID=HART_ID again
cfu_reg 4,x15,x13,x14   ; u0.f4
....

<<mux22-wave>> is an example waveform executing <<cim3>>
near-simultaneously on the two CPUs of <<mux22>>.

(_1:u2<3>.f4_ denotes a CFU request with REQ_ID=1 CFU_ID=2 STATE_ID=3 CF_ID=4)

In the narrative that follows, that _A sends B_ means _A asserts B
ahead of next posedge `clk`,_ whereas _B transfers to C_ means _during
this cycle C receives and accepts it_. Recall with CFU-L2, request
transfers occur when both `req_valid` and `req_ready` are asserted
(§<<flow-control>>), whereas response transfers occur when `resp_valid`
is asserted.

[[mux22-wave]]
.Example 2-input 2-output CFU-L2 Mux CFU signaling protocol waveform
[wavedrom,target="cfu-2x2",svg]
....
{signal: [
{    name: 'clk',       wave: 'P..................'},
['CPU-0',
{  name: 'req_valid',   wave: '01..01...01...0....' },
{  name: 'req_ready',   wave: '010101010....10....'  },
{  name: 'req_*',       wave: 'x23.x45.x2....x....', data: '0:u0 1:u0<0>.f1 2:u1 3:u1<0>.f3 4:u0<0>.f4' },
{  name: 'resp_*',      wave: 'x.x.2x3x4x...5x.2x.', data: '0:ok 1:ok 2:ok 3:ok 4:ok' },
],
{},
['CPU-1',
{  name: 'req_valid',   wave: '01...01...01...0...' },
{  name: 'req_ready',   wave: '0.101010.10...10...'  },
{  name: 'req_*',       wave: 'x6.7.x89..x6...x...', data: '5:u0<1> 6:u0<1>.f1 7:u1 8:u1<1>.f3 9:u0<1>.f4' },
{  name: 'resp_*',      wave: 'x..x.6x7x.8x..9x.6x', data: '5:ok 6:ok 7:ok 8:ok 9:ok' },
],
{},
['CFU-0',
{  name: 'req_valid',   wave: '0.1...0.......1.0..' },
{  name: 'req_ready',   wave: '01.................'  },
{  name: 'req_*',       wave: 'x.2637x.......26x..', data: '0:u0 5:u0 1:u0 6:u0 4:u0 9:u0' },
{  name: 'resp_*',      wave: 'x..2637x.......26x.', data: '0:ok 5:ok 1:ok 6:ok 4:ok 9:ok' },
],
{},
['CFU-1',
{  name: 'req_valid',   wave: '0.....1......0.....' },
{  name: 'req_ready',   wave: '01......010.1......'  },
{  name: 'req_*',       wave: 'x.....485.9..x.....', data: '2:u1 7:u1 3:u1<0>.f3 8:u1<1>.f3' },
{  name: 'resp_*',      wave: 'x......4x8x.59x....', data: '2:u1 7:u1 3:u1 8:u1' },
],
],
head:{ tick:'0' },
foot:{ tock:'0'
}
}
....

Cycle-by-cycle:

[arabic]
. Both CPUs CSR-write their hart's `mcfu_selector` registers, selecting CFU_ID=0=CFU~0~, and their hart's STATE_ID. +
Both CPUs issue the first CF instruction (`f0`).

[arabic]
. CPU~0~ sends first CFU request: REQ_ID=0 CFU_ID=0 STATE_ID=0 CF_ID=0, a.k.a. `0:u0<0>.f0`. +
CPU~1~ sends first CFU request: REQ_ID=5 CFU_ID=0 STATE_ID=1 CF_ID=0, a.k.a. `5:u0<1>.f0`.
. CPU~0~'s first request, destined for CFU~0~, wins arbitration for Mux output port 0. +
Mux asserts CPU~0~'s `req_ready` and negates CPU~1~'s `req_ready`. +
CPU~0~'s first request `0:u0<0>.f0` transfers to Mux. +
Mux sends CPU~0~'s first request to `Cvt12(CFU~0~)` +
CPU~0~ sends second CFU request: `1:u0<0>.f1`.
. CPU~1~'s first request, destined for CFU~0~, wins arbitration for Mux output port 0. +
Mux asserts CPU~1~'s `req_ready` and negates CPU~0~'s `req_ready`. +
CPU~1~'s first request `5:u0<1>.f0` transfers to Mux. +
Mux sends CPU~1~'s first request to `Cvt12(CFU~0~)`. +
CPU~1~ sends second CFU request: `6:u0<0>.f1`. +
CPU~0~'s first request `0:u0<0>.f0` transfers to CFU~0~. +
CFU~0~ executes `0:f0`, updates state `<0>`, sends response to Mux.
. CPU~0~ sends no CFU request this cycle, due to its second `csrw` execution cycle. +
CPU~0~'s second request `1:u0<0>.f1`, wins arbitration, transfers to Mux, is sent to `Cvt12(CFU~0~)`. +
CPU~1~'s first request `5:u0<1>.f0` transfers to CFU~0~, executes, updates `<1>`, sends response to Mux. +
CFU~0~'s response to CPU~0~'s first request transfers to Mux, is sent to CPU~0~.
. CPU~1~ sends no CFU request this cycle, due to its second `csrw` execution cycle. +
CPU~1~'s second request `6:u0<0>.f1`, wins arbitration, transfers to Mux, is sent to `Cvt12(CFU~0~)`. +
CPU~0~'s second request `1:u0<1>.f1` transfers to CFU~0~, executes, updates `<0>`, sends response to Mux. +
CFU~0~'s response to CPU~1~'s first request transfers to Mux, is sent to CPU~1~. +
CFU~0~'s response to CPU~0~'s first request transfers to CPU~0~.
. CPU~0~ bubble in CFU request issue due to its second `csrw` execution cycle. +
CPU~1~ sends third request `2:u1<1>.f2`, with CFU_ID=1, destined for CFU~1~. +
CPU~0~'s third request `2:u1<0>.f2`, transfers to Mux, is sent to CFU~1~. +
CPU~0~ sends fourth request `3:u1<0>.f3`, with CFU_ID=1, destined for CFU~1~. +
CPU~1~'s second request `6:u0<1>.f1` transfers to CFU~0~, executes, updates `<1>`, sends response to Mux. +
CFU~0~'s response to CPU~0~'s second request transfers to Mux, is sent to CPU~0~. +
CFU~0~'s response to CPU~1~'s first request transfers to CPU~1~.
. CPU~1~'s third request `7:u1<0>.f2` wins arbitration, transfers to Mux, is sent to CFU~1~. +
CPU~1~ sends fourth request `8:u1<0>.f3`, with CFU_ID=1, destined for CFU~1~. +
CPU~0~'s third request `2:u1<0>.f2` transfers to CFU~1~, executes, updates `<0>`, sends response to Mux. +
CFU~0~'s response to CPU~1~'s second request transfers to Mux, is sent to CPU~1~. +
CFU~0~'s response to CPU~0~'s second request transfers to CPU~0~.
. CPU~0~ sends no CFU request this cycle, due to its third `csrw` execution cycle. +
CPU~0~'s fourth request `3:u1<0>.f3` wins arbitration, transfers to Mux, is sent to CFU~1~. +
CPU~1~'s third request `7:u1<1>.f2` transfers to CFU~1~, begins execution. +
CFU~1~'s response to CPU~0~'s third request transfers to Mux, is sent to CPU~0~. +
CFU~0~'s response to CPU~1~'s second request transfers to CPU~1~.
. CPU~1~ sends no CFU request this cycle, due to its third `csrw` execution cycle. +
CPU~0~ sends fifth request `4:u0<0>.f4`, with CFU_ID=0, destined for CFU~0~. +
At CFU~1~, CPU~1~'s third request `7:u1<0>.f2` completes execution, updates `<1>`, sends response to Mux. +
CFU~1~'s response to CPU~0~'s third request transfers to CPU~0~.
. CPU~0~'s fifth CFU request is _ineligible_ to transfer because CPU~0~ has pending requests to CFU~1~. It becomes eligible at cycle 13. +
CPU~1~'s fourth request `8:u1<0>.f3` transfers to Mux, is sent to CFU~1~. +
CPU~0~'s fourth request `3:u1<0>.f3` transfers to CFU~1~, begins execution. +
CFU~1~'s response to CPU~1~'s third request transfers to Mux, is sent to CPU~1~.
. CPU~1~ sends fifth request `9:u0<1>.f4`, with CFU_ID=0, destined for CFU~0~. +
CPU~0~'s fourth CFU request `3:u1<0>.f3` continues execution. +
CFU~1~'s response to CPU~1~'s third request transfers CPU~1~.
. CPU~1~'s fifth CFU request is _ineligible_ to transfer because CPU~1~ has pending requests to CFU~1~. It becomes eligible at cycle 14. +
CPU~0~'s fourth CFU request `3:u1<0>.f3` completes execution, updates `<0>`, sends response to Mux.
. CPU~1~'s fourth request `8:u1<1>.f3` transfers to CFU~1~, executes, updates `<1>`, sends response to Mux. +
CFU~1~'s response to CPU~0~'s fourth request transfers to Mux, is sent to CPU~0~.
. CFU~1~'s response to CPU~0~'s fourth request transfers to CPU~0~. +
CPU~0~'s fifth request `4:u0<0>.f4` becomes eligible, transfers to Mux, is sent to CFU~0~.
. CFU~1~'s response to CPU~1~'s fourth request transfers to CPU~1~. +
CPU~1~'s fifth request `9:u0<1>.f4` becomes eligible, transfers to Mux, is sent to CFU~1~. +
CPU~0~'s fifth request `4:u0<0>.f4` transfers to CFU~0~, executes, updates `<0>`, sends response to Mux.
. CPU~1~'s fifth request `9:u0<1>.f4` transfers to CFU~0~, executes, updates `<1>`, sends response to Mux. +
CFU~0~'s response to CPU~0~'s fifth request transfers to Mux, is sent to CPU~0~.
. CFU~0~'s response to CPU~1~'s fifth request transfers to Mux, is sent to CPU~1~. +
CFU~0~'s response to CPU~0~'s fifth request transfers to CPU~0~.
. CFU~0~'s response to CPU~1~'s fifth request transfers to CPU~1~.

=== Composing CFUs with AXI4-Streams

In some configured systems, preexisting infrastructure components
that implement AXI4-Stream protocol may be used to help compose CPUs
and CFUs. A fully flow controlled CFU-LI -L3 or -L4 transfer may be
transported over two AXI4-Stream (AXI-S) streams, one for requests and
one for responses.

[TIP]
====
For example, in a Xilinx Versal FPGA, a CPU might transfer CFU requests,
via CFU-L3-to-AXI-S bridge, AXI-S-to-NOC bridge, Versal NOC, NOC-to-AXI-S
bridge, AXI-S-to-CFU-L3 bridge, to a CFU at the far corner of the FPGA
fabric, later transferring CFU responses back to the _distant_ CPU by
the same means.
====

<<cfu-axis>> presents a recommended canonical mapping between CFU-LI
signals and the two AXI-S streams.

[[cfu-axis]]
.Recommended mapping between CFU-L3/-L4 and request/response AXI4-Streams
[width="80%",cols="9%,24%,26%,41%",options="header,unbreakable"]
|===
^|*Dir* |*CFU-LI Port* |*Width* |*AXI-S Port*
^|in |`clk` | |`aclk`
^|in |`rst` | |`aresetn` *
^|in |`clk_en` | |-
^|in |`req_valid` | |`reqs_tvalid`
^|out |`req_ready` | |`reqs_tready`
^|in |`req_id` |`CFU_REQ_ID_W` |`reqs_tid` _or_ `reqs_tdest`
^|in |`req_cfu` |`CFU_CFU_ID_W` |`reqs_tuser` _or_ `reqs_tdest`
^|in |`req_state` |`CFU_STATE_ID_W` |`reqs_tuser`
^|in |`req_func` |`CFU_FUNC_ID_W` |`reqs_tuser`
^|in |`req_insn` |`CFU_INSN_W` |`reqs_tuser`
^|in |`req_data0` |`CFU_DATA_W` |`reqs_tdata`
^|in |`req_data1` |`CFU_DATA_W` |`reqs_tdata`
^|in |- | |`reqs_tlast` _optional_
^|in |- |* |`reqs_tstrb` _optional_
^|in |- |* |`reqs_tkeep` _optional_
^|out |`resp_valid` | |`resps_tvalid`
^|in |`resp_ready` | |`resps_tready`
^|out |`resp_id` |`CFU_REQ_ID_W` |`resps_tid` _or_ `resps_tdest`
^|out |`resp_data` |`CFU_DATA_W` |`resps_tdata`
^|out |`resp_status` |`CFU_STATUS_W` |`resps_tuser`
^|out |- | |`resps_tlast` _optional_
^|out |- |* |`resps_tstrb` _optional_
^|out |- |* |`resps_tkeep` _optional_
|===

When several CFU-LI signals map to a single AXI-S port, the signals
are to be concatenated in order, each signal assigned successively more
significant bits. For example, using Verilog concatenation:

[code,verilog]
....
reqs_tuser = { req_insn,req_func,req_state,req_cfu };
reqs_tdata = { req_data1,req_data0 };
....

Use `reqs_tdest` when `req_id` and/or `req_cfu` indicate/encode a
specific AXI-S destination (of a bridge to a CFU).  Use `resps_tdest`
when of `resp_id` indicates a specific AXI-S destination (of a bridge
to a requester, e.g., CPU).

