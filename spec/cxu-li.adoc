[[cxu-li]]
== Composable Extension Unit Logic Interface

The CXU-LI defines a set of common hardware logic signaling extensions
enabling straightforward, correct composition of CPUs and CXUs. In the
CXU-LI, a CPU is a requester and a CXU is a responder. The CPU sends
a CXU request and eventually receives a CXU response. For each request
there is exactly one response.

=== Definitions

[[cxu_request]]
A *CXU request (request)* is a group of CXU-LI signals that may
include request flow control, <<REQ_ID,REQ_ID>>, <<CXU_ID,CXU_ID>>,
<<FUNC_ID,FUNC_ID>>, <<STATE_ID,STATE_ID>>, the raw instruction, and integer
operands, produced by a CXU requester, conveying request data to a CXU.

A *CXU response (response)* is a group of CXU-LI signals that may include
response flow control, <<REQ_ID,REQ_ID>>, response status, and integer
result, produced by a CXU, conveying response data to a CXU requester.

[[REQ_ID]]
A *request ID (REQ_ID)* is a tag (a _magic cookie_) that correlates
a CXU request and its corresponding CXU response.

A *CXU response status (response status, status)* is a CXU-LI
success/error code produced by a CXU in response to receiving a
CXU request, indicating success or else an error in the request's
<<CXU_ID,CXU_ID>>, <<FUNC_ID,FUNC_ID>>, <<STATE_ID,STATE_ID>>, operation,
or a composable extension specific error.

A *CXU requester* (requester) is a core that sends CXU requests to CXU(s)
and receives CXU response(s) from CXUs.

A *CPU* is a CXU requester that implements RISC-V RV-I-Zicsr + _(CX-ISA
extension)_ instruction set, issues CXU requests upon issuing custom
function instructions and custom CSR access instructions (collectively,
_custom operation_ instructions), and writes a destination register and
the CX status CSR in response to CXU responses.

A *composable extension unit (CXU, responder)* is a core that implements
one or more composable extensions. It receives CXU requests and sends CXU
responses to CXU requesters. A CXU that also issues CXU requests is an
*intermediary CXU*; otherwise it is a *leaf CXU*.

A *Switch CXU (switch)* is an intermediary CXU. For each request received,
the switch either sends a response itself (e.g., a CXU_ERROR_CXU response)
or arbitrates and forwards the request to a subordinate CXU, and later
forwards the corresponding response to the original requester.

A *CXU feature level adapter (adapter)* is an intermediary CXU that
receives requests and sends responses at one CXU-LI feature level and
adapts them for and forwards them to a subordinate CXU with a lesser
feature level.

A *configured system (system)* is a computer system including one or
more CPUs and zero or more CXUs that implement a set of configured
composable extensions.

=== Example configured system

<<configured-system>> illustrates a configured system composed of two
CPUs and five CXUs, plus two switches and a level adapter for CXU~3~. Each CPU
has two harts. CXUs 0-2 are stateful and CXUs 3-4 are stateless. Each
stateful CXU has one state context per hart. CXU~1~ has an additional
state context per hart for isolated stateful requests from CXU~2~.

[[configured-system]]
.Configured system composed of two CPUs and five CXUs
image::composed-cxus.png[image,width=420]

In general, a CPU that issues one CXU request per cycle is directly
coupled to one CXU, usually a switch CXU. A system of CXUs forms a directed
acyclic graph.

=== CXU-LI feature levels

The CXU-LI is stratified into separate feature levels: -L0: combinational;
-L1: fixed latency; -L2: variable latency; and -L3: reordering.
Each feature level adds yet more CXU request and response
signals, module ports, and behaviors to the feature level below it.

[TIP]
====
Stratification keeps simple use cases simple and frugal, and makes more
complex use cases possible.
====

==== CXU-L0: combinational CXU

The CXU, which implements a stateless composable extension, computes a
combinational function of the CXU request, sending a CXU response after
some propagation delay. There is no flow control.

[TIP]
====
Example: combinational bitmanip unit with a population count custom function.
====

[[cxu-l1]]
==== CXU-L1: fixed latency CXU

Each cycle, the CXU computes a function of the CXU request *and the
specified state context, if any, updating the context*, sending a
CXU response after a configured *fixed non-negative number of clock
cycles*. With an initiation interval of II=1/cycle, there is no flow
control of requests or responses.

[TIP]
====
Examples: stateless: a pipelined multiplier; stateful: a pipelined
multiply-accumulate unit wherein the state is the current total.
====

[NOTE]
====
Perhaps minimum II should also be configurable, e.g. CXU_INIT_INTERVAL=1+.
====

[[cxu-l2]]
==== CXU-L2: variable latency CXU

The CXU computes a function of the CXU request and the specified state
context, if any, updating the context, sending a CXU response, *in order,
in a later clock cycle*. There is *request and response flow control*
so the CXU can suspend receiving requests and the CPU can suspend
receiving responses.

[TIP]
====
Example: a multiply-divide unit with a variable-latency multi-cycle
divide, with early-out.
====

[[cxu-l3]]
==== CXU-L3: reordering CXU

The CXU computes a function of the CXU request and the specified state
context, if any, updating the context, and sending a CXU response in a
later clock cycle. *Responses for requests with the same state context
are sent in order, otherwise may be sent out of order*. There is request
and response flow control.

CXU-L3 incorporates a <<req-resp-id,request-response ID>> for the
requester to correlate responses received to requests sent.

[TIP]
====
Example: a stateless, variable latency posit floating point unit, which,
having received a pdiv request then a pmul request, responds out of order,
sending the pmul response ahead of the pdiv response.
====

==== Feature levels summary

In summary, all CXU-LI feature levels have request and response function,
data, and status. Level 0 is combinational. Level 1 adds clocking,
fixed latency, and state contexts. Level 2 adds variable latency and
request and response flow control and the raw instruction.
Level 3 adds reordering. (<<levels-table>>.)

[[levels-table]]
.CXU-LI feature levels summary
[width="100%",cols="7%,16%,20%,25%,20%,12%",options="header",]
|===
^|*Level* |*CXU type* ^a|
*Req valid, func, data, resp data, status*
^|*Clock, reset, clock enable, state ID, resp valid* ^|*Req ready, resp ready, raw insn* ^|*Reordering, req ID*
^|0 |combinational ^|Y ^| ^| ^|
^|1 |fixed latency ^|Y ^|Y ^| ^|
^|2 |variable latency ^|Y ^|Y ^|Y ^|
^|3 |reordering ^|Y ^|Y ^|Y ^|Y
|===

[TIP]
====
Compared to all possible subsets of features, CXU-LI levels are
relatively simple and practical. Each level is a superset of lower
levels, simplifying composition of dissimilar CXUs using common CXU
feature level adapters.
====

=== CXU-LI signaling

CXU cores _of a particular feature level_ implement a common set
of request and response signals. <<cxu-signals>> lists all CXU-LI
signals of all feature levels in a canonical order: transaction
signals (request/response valid, ready, <<REQ_ID,REQ_ID>>), context
(<<CXU_ID,CXU_ID>>, <<STATE_ID,STATE_ID>>), function (raw instruction,
<<FUNC_ID,FUNC_ID>>), and data. The Level column indicates which levels introduce
which signals. The Dir column indicates the signal direction from the
perspective of a responder. The bit width of each bit vector is determined
by a width parameter, configurable per CXU
(ยง<<parameters>>).

[[cxu-signals]]
.All CXU-LI signals, by feature level
[width="100%",cols="11%,8%,22%,24%,35%",options="header",]
|===
^|*Level* ^|*Dir* |*Port* |*Width Parameter* |*Description*
^|1+ ^|in |`clk` | |clock
^|1+ ^|in |`rst` | |reset
^|1+ ^|in |`clk_en` | |clock enable
^| ^|in |`req_valid` | |request valid
^|2+ ^|out |`req_ready` | |request ready
^|3 ^|in |`req_id` |`CXU_REQ_ID_W` |request <<REQ_ID,REQ_ID>>
^| ^|in |`req_cxu` |`CXU_CXU_ID_W` |request <<CXU_ID,CXU_ID>>
^|1+ ^|in |`req_state` |`CXU_STATE_ID_W` |request <<STATE_ID,STATE_ID>>
^| ^|in |`req_func` |`CXU_FUNC_ID_W` |request <<FUNC_ID,FUNC_ID>>
^|2+ ^|in |`req_insn` |`CXU_INSN_W` |request raw instruction
^| ^|in |`req_data0` |`CXU_DATA_W` |request operand data 0
^| ^|in |`req_data1` |`CXU_DATA_W` |request operand data 1 / CSR address
^|1+ ^|out |`resp_valid` | |response valid
^|2+ ^|in |`resp_ready` | |response ready
^|3 ^|out |`resp_id` |`CXU_REQ_ID_W` |response ID
^| ^|out |`resp_status` |`CXU_STATUS_W` |response status
^| ^|out |`resp_data` |`CXU_DATA_W` |response data
|===

All signals are positive-true logic.

[[parameters]]
==== CXU-LI configuration parameters

<<width-parameters>> presents CXU-LI bit vector width parameters and
ranges of possible values.

[[width-parameters]]
.CXU-LI width configuration parameters
[width="100%",cols="8%,12%,18%,8%,10%,44%",options="header",]
|===
^|*Level* |*Quantity* |*Width Parameter* |*Range* |*Default* |*Description*
^|3 |<<REQ_ID,REQ_ID>> |`CXU_REQ_ID_W` |0-64 |0 |request/response ID width
^| |<<CXU_ID,CXU_ID>> |`CXU_CXU_ID_W` |0-16 |0 |CXU_ID width
^|1+ |<<STATE_ID,STATE_ID>> |`CXU_STATE_ID_W` |0-16 |0 |STATE_ID width
^| |<<FUNC_ID,FUNC_ID>> |`CXU_FUNC_ID_W` |3-11 |11 |FUNC_ID width
^|2+ |`insn` |`CXU_INSN_W` |0, 32 |0 |raw instruction width
^| |`data` |`CXU_DATA_W` |32, 64 |32 |request/response data width
^| |`status` |`CXU_STATUS_W` |3 |3 |response status width
|===

[TIP]
====
Zero width bit vectors are problematic in some HDLs. Parameter signals
declared 0-bits wide should nevertheless be declared [0:0], driven 1'b0
by sender, and ignored by receiver.
====

<<other-parameters>> presents other CXU configuration parameters.

[[other-parameters]]
.CXU-LI: other CXU configuration parameters
[width="100%",cols="8%,21%,12%,12%,47%",options="header,unbreakable",]
|===
^|*Level* |*Parameter* |*Range* |*Default* |*Description*
^| |`CXU_LI_VERSION` |`24'h010000` | `24'h010000` |CXU-LI version; `24'h01_00_00` == 1.00.00
^| |`CXU_N_CXUS` |1+ |1 |number of CXUs at/below this CXU
^|1+ |`CXU_N_STATES` |0+ |0 |number of composable extension state contexts
^|1 |`CXU_LATENCY` |0+ |1 |latency (clock cycles) from a request to its response
^|1 |`CXU_RESET_LATENCY` |0+ |0 |min. latency (clock cycles) from negation of reset to first request
|===

`CXU_LI_VERSION` indicates the version of the CXU-LI signals and semantics
in effect, using semantic versioning
https://semver.org, encoded as `24'hxx_yy_00`: (major=xx,minor=yy,patch=00).
Since `CXU_LI_VERSION` is an extension specification and not an
implementation, there is never a patch level. See also ยง<<versioning>>.

[TIP]
====
`CXU_LI_VERSION` anticipates subsequent evolution of CXU-LI.
====

`CXU_N_CXUS` is the number of logical CXUs at/below this CXU. For
a leaf CXU this may be more than one when the CXU implements multiple
composable extensions (including multiple versions of one composable extension).

`CXU_N_STATES` is the number of composable extension state contexts for
every stateful extension implemented by this CXU. It must be 0 if every
composable extension implemented by the CXU is stateless. It must be 1+ if
any composable extension implemented by the CXU is stateful. When a leaf CXU
implements multiple stateful composable extensions, i.e. `CXU_N_CXUS>1`,
each must be configured with the same number of state contexts.

`CXU_LATENCY` and `CXU_RESET_LATENCY` are specific to CXU-L1 fixed
latency CXUs. See ยง<<cxu-l1>>.

[[clocking]]
==== Clock, reset, clock enable

CXU-L0 is combinational. Other feature levels' signaling is (mostly)
synchronous to rising edge (_posedge_) of `clk`.

When the reset input signal `rst` is asserted on posedge `clk`, it
supersedes all other CXU-LI signaling. Any request processing in
progress is abandoned, all internal state is reset, and `req_ready`
and `resp_valid` output signals, if present, are negated. A CXU-L1 CXU
(which does not have a `req_ready` output) must be ready to receive
its first request after no more than its configured `CXU_RESET_LATENCY`
clock cycles following negation of `rst`.

A clock enable input signal `clk_en` facilitates clock gating of a
CXU. When `clk_en` is asserted on posedge `clk`, synchronous elements of
the CXU (i.e., memories, registers, flip-flops) may change. When `clk_en`
is negated on posedge `clk`, no changes may occur to synchronous elements
of the CXU. CXU operation is suspended. Therefore, when negating `clk_en`,
a CXU requester must disregard all CXU output signals, esp. `req_ready`
and `resp_valid`.

[TIP]
====
In the twilight of Moore's Law, energy efficiency is a first order
design concern, and it is a shame to burn power computing routinely
discarded results.
====

[TIP]
====
All modern FPGAs enable simple clock gating via _free_ `clk_en` inputs
on all LUT-cluster D flip-flops.
====

[TIP]
====
If a requester never clock gates a CXU with `clk_en`, it should assert
`clk_en` with a constant `'1`. FPGA and ASIC implementation tools typically
optimize away such signals and their D flip-flop clock enables.
====

[NOTE]
====
Perhaps provide another configuration parameter `CXU_USE_CLK_EN=0/1` to
configurably-ignore `clk_en`. This could simplify conversion of
preexisting RTL function units, sans `clk_en` gating, into new CXUs.
====

[[flow-control]]
==== Request and response valid-ready flow control

CXU-L2 and -L3 provide CXU request and response channel synchronous
valid-ready flow control. For each channel, the sender may assert data
and a positive-true data `valid` signal indicating it is ready to send
data. The receiver may assert a positive-true `ready` signal indicating it
is ready to receive data. On posedge `clk`, if both `valid` and `ready` are
asserted, data transfers from sender to receiver; otherwise, no transfer
occurs during that clock cycle.

Once a sender asserts data and asserts data `valid` on posedge `clk`,
it must assert the same data and `valid` on each subsequent posedge `clk`
until the receiver asserts `ready` and the transfer occurs.

A `valid` output must not depend (via combinational logic) upon a `ready`
input. However, a `ready` output may depend upon a `valid` input.

With request and response flow control, a requester must not indefinitely
negate `resp_ready` in response to a responder negating `req_ready`.

[TIP]
====
This precludes a potential cyclical wait deadlock in a composed system.
====

[[error-checking]]
==== Response status / error checking

At any feature level, in response to receiving a CXU request, the CXU
error-checks the request data, performs the request, and outputs the first
(i.e., lowest numbered) `[2:0] resp_status` condition that applies:

.CXU response status values and conditions
[width="100%",cols="23%,7%,70%",options="header",]
|===
|Name |Value |Condition
|`CXU_OK` |0 |no errors occurred processing request
|`CXU_ERROR_CXU` |1 |`req_cxu` is not a CXU_ID implemented by CXU
|`CXU_ERROR_STATE` |2 |`req_state` is not a valid STATE_ID for `req_cxu`
|`CXU_ERROR_OFF` |3 |`req_state` is valid but this <<serializable,_serializable_>> state context is in the _off_ state
|`CXU_ERROR_FUNC` |4 |`req_func` is not a valid CF_ID / `req_data1` is not a valid CSR address / write access to a read-only CSR
|`CXU_ERROR_OP` |5 |request operand(s) or state are a domain error for the custom function or custom CSR access
|`CXU_ERROR_CUSTOM` |6 |request causes a custom error (of a serializable composable extension)
|===

When parameter `CPU_CXU_ID_W=0`, `req_cxu` is ignored: no `CXU_ERROR_CXU`
errors.

When parameter `CPU_STATE_ID_W=0`, `req_state` is ignored: no
`CXU_ERROR_STATE` errors.

`STATE_ID=0` is the only valid STATE_ID for the CXU of a stateless
composable extension.

CXU state may change if and only if the response status is one of
`CXU_OK`, `CXU_ERROR_OP`, or `CXU_ERROR_CUSTOM`.

[TIP]
====
When a response status is `CXU_ERROR_CUSTOM`, the CXU should update
the specified state context's custom error status as a side effect of
the request. Otherwise, a CX library may be surprised to observe that the
custom error bit `cx_status.CU` is set without observing a corresponding
error bit upon retrieving (via `cx_read_status`) its state context's
error state.
====

In response to receiving `resp_status` of `CXU_ERROR_CXU`,
`CXU_ERROR_STATE`, `CXU_ERROR_OFF`, or `CXU_ERROR_FUNC`, a CPU ignores
`resp_data` and uses zero as the result of the CF instruction.

When a CF instruction writes a destination register, (i.e.,
`custom-[01]` but not `custom-2`), the result of the CF instruction
is written to the register, irrespective of the CXU response status.

[TIP]
====
Can certain errors suppress destination register writes? No: data
dependent writeback cancelation is irregular and unnecessarily complicates
out of order CPUs.
====

[TIP]
====
Together these rules ensure { CXU, state, function } ID errors are
well behaved at the hardware-software extension. By making the CPU
responsible for zeroing such results, each CXU in a system's CXU DAG
need not incur redundant logic and delay to respond `resp_data=0` on
these three errors. For synchronously signaled CXU-LI levels, in an FPGA,
with reset-able flip-flops, a registered `resp_data` input may be zeroed
for negligible cost.
====

==== Function ID
The CXU request <<FUNC_ID,FUNC_ID>> `req_func` indicates the custom operation to perform:
when the most-significant bit of `req_func` is 0, the remaining
bits are the <<CF_ID,CF_ID>> of a custom opcode instruction;
when the most-significant bit of `req_func` is 1, bits `req_func[1:0]`
encode one of four CSR access requests:

.FUNC_ID CSR access requests
[width="100%",cols="8%,8%,18%,66%",options="header",]
|===
|*Value* |*Req.* |*Description* |*Behavior*
|`1:0` |`CSRR` |read-only access  |`resp_data = CSRs[req_data1];`
|`1:1` |`CSRRW` |read-write access |`resp_data = CSRs[req_data1]; CSRs[req_data1] = req_data0;`
|`1:2` |`CSRRS` |read-set access |`resp_data = CSRs[req_data1]; CSRs[req_data1] \|= req_data0;`
|`1:3` |`CSRRC` |read-clear access |`resp_data = CSRs[req_data1]; CSRs[req_data1] &= ~req_data0;`
|===

The minimum `CXU_FUNC_ID_W` is 3: 1-bit MSB + 2-bit CSR access request type;
the maximum is 11: 1-bit MSB + maximum 10-bit `CF_ID_W`.

[NOTE]
====
Perhaps the spec should require "When the most-significant bit of
`req_func` is 1, bits `req_func[CXU_FUNC_ID_W-2:2]` must be 0."
====

[[raw-insn]]
==== Raw instruction

At CXU-LI feature level 2, or higher, CXU requests may be configured
(`CXU_INSN_W=32`) to include the raw instruction word (`req_insn`) of the
custom operation instruction that issued the CXU request, or all zeroes
otherwise. A CXU may use the raw instruction data to help perform the
custom operation, or it may ignore the raw instruction entirely.

[TIP]
====
The raw instruction complements the <<CF_ID,CF_ID>>-derived
<<FUNC_ID,FUNC_ID>> `req_func` identifier. CF_ID is the preferred, future
proof way to select a custom function. It is ISA neutral and abstracts
the CPU away from CXU, and potentially reduces verification complexity.
====

[TIP]
====
However, access to the raw CF instruction word can enable additional
use cases. As an example, consider a CXU with a private vector, matrix,
or complex number register file. When this CXU receives a CXU request
including its raw instruction word, it may opt to ignore either or
both of the two integer request operands `req_data0` and `req_data1`,
and instead partially decode the raw instruction word to recover `rs1`
and `rs2` fields, even `rs3` if there are spare custom instruction bits,
to determine which of its CXU register file entries to read. Similarly,
the CXU can decode the raw instruction word to recover an `rd` field
to determine which CXU-private register file entry to write back and
whether to do so.
====

[TIP]
====
This feature is best used with the <<custom-2,`custom-2`>> flex
instruction format which has no `rd` destination register field,
freeing those bits for arbitrary uses.
====

[NOTE]
====
Does raw instruction access merits security threat modeling? Imagine
adversarial CXUs, snoopily watching the dynamic instruction stream go by,
even when `req_valid` is negated.
====

[NOTE]
====
At present the custom instructions and CSR access instructions are 32b
instructions. If this changes, CXU_INSN_W may have values other than
0 and 32.
====

[NOTE]
====
Half-baked idea (not recommended): Imagine a dynamic facility by which any
arbitrary instruction word, not just `custom-[012]` format instructions,
may be a CF instruction, issued to a CXU. This might be a table of
(mask,pattern) tuples, or a 32-bit `mcx_opcodes_mask` CSR bit vector of
5-bit major opcodes, identifying instructions to divert to the current
CXU. Or perhaps, in the hardware domain, a CPU might first issue each
instruction to the current CXU, and only execute the instruction in the
CPU if the CXU delegates it back to the CPU.
====

[[req-resp-id]]
==== Request-response ID

CXU-LI feature level 3 <<cxu-l3,(reordering CXU)>> includes a request-response
ID <<REQ_ID,REQ_ID>>, a `REQ_ID_W` -bit signal used by requesters to
correlate responses received with requests sent. With each request, the
CXU receives the REQ_ID as `req_id`, and later, with each response, the
CXU sends back the same REQ_ID as `resp_id`. For each request/response
pair, the CXU must send the requester the identical request-response ID
value that the requester previously sent to the CXU.

Operation and behavior of a CXU must not depend in any way upon any
`req_id` value received, except to receive it and later to return it
to the requester.

[TIP]
====
An out-of-order completion CPU may send a REQ_ID indicating the
destination register of the request, and rely upon it when the response
eventually returns.
====

=== CXU-L0 combinational CXU signaling

A combinational CXU, which implements a stateless composable extension,
computes a combinational function of the CXU request, sending a CXU
response after some propagation delay. There is no flow control.

==== CXU-L0 configuration parameters

.CXU-L0 configuration parameters
[width="100%",cols="37%,63%",options="header",]
|===
|*Parameter* |*Description*
|`CXU_LI_VERSION` |CXU-LI version number
|`CXU_N_CXUS` |number of CXUs at/below this CXU
|===

For `CXU_LI_VERSION` and `CXU_N_CXUS`, see ยง<<parameters>>.

==== CXU-L0 signals

.CXU-L0 signals
[width="100%",cols="10%,17%,22%,51%",options="header",]
|===
^|*Dir* |*Port* |*Width Parameter* |*Description*
^|in |`req_valid` | |request valid
^|in |`req_cxu` |`CXU_CXU_ID_W` |request <<CXU_ID,CXU_ID>>: selects the requested CXU
^|in |`req_func` |`CXU_FUNC_ID_W` |request <<FUNC_ID,FUNC_ID>>
^|in |`req_data0` |`CXU_DATA_W` |request operand data 0
^|in |`req_data1` |`CXU_DATA_W` |request operand data 1
^|out |`resp_status` |`CXU_STATUS_W` |response status
^|out |`resp_data` |`CXU_DATA_W` |response data
|===

CXU-L0 signaling is asynchronous. CXU outputs are pure combinational
functions of CXU inputs.

[TIP]
====
CXU-L0 has no `resp_valid` signal because it would just reflect `req_valid`.
====

==== CXU-L0 signaling protocol

Protocol:

[arabic]
. Request transfer
[loweralpha]
.. Requester asserts CXU request signals `req_*` and asserts `req_valid`.
.. CXU asynchronously receives CXU request.
. Response transfer
[loweralpha]
.. CXU performs steps 1, 2, 4, and 6 of response status / error checking per ยง<<error-checking>>, and asserts `resp_status`.
.. CXU asserts `resp_data`, a combinational custom function of the operands.
.. Requester asynchronously receives CXU response.

As a CXU-L0 CXU is combinational, its delay folds into to the path timing
analysis of its requester.

==== CXU-L0 example

[[cxu-l0-wave]]
.Example CXU-L0 signaling protocol waveform
[wavedrom,target="cxu-l0",svg,width="90%"]
....
{signal: [
['Request',
{  name: 'req_valid',   wave: '0101.0' },
{  name: 'req_cxu',     wave: 'x3x45x', data: 'u0 u0 u0 u0'  },
{  name: 'req_func',    wave: 'x3x45x', data: 'f0 f1 f2 f3' },
{  name: 'req_data0',   wave: 'x3x45x', data: 'a0 a1 a2 a3' },
{  name: 'req_data1',   wave: 'x3x45x', data: 'b0 b1 b2 b3' },
],
['Resp.',
{  name: 'resp_status',  wave: 'xx3x45x', data: 'ok err1 ok ok', phase: 1.5  },
{  name: 'resp_data',   wave: 'xx3x45x', data: 'res0 0 res2 res3', phase: 1.5 },
]
], config: { hscale: 2 },
}
....

<<cxu-l0-wave>> is an example waveform for three CXU-L0 requests
and responses, arising from executing custom function instructions
`f0(a0,b0)`, `f1(a1,b1)`, and `f2(a2,b2)`. All three instructions issue
to the same CXU `u0`. Function `f1` incurs an error.

=== CXU-L1 fixed latency CXU signaling

Each cycle, a fixed latency CXU computes a function of the CXU request
*and the specified state context, if any, updating the context*, sending
a CXU response after a configured *fixed non-negative number of clock
cycles*. With an initiation interval of II=1/cycle, there is no flow
control of requests or responses.

Lacking request flow control, if a CXU-L1 CXU is configured with multiple
requesters, requesters must not send multiple simultaneous requests.

==== CXU-L1 configuration parameters

.CXU-L1 configuration parameters
[width="100%",cols="25%,75%",options="header",]
|===
|*Parameter* |*Description*
|`CXU_LI_VERSION` |CXU-LI version number
|`CXU_N_CXUS` |number of CXUs at/below this CXU
|`CXU_N_STATES` |number of composable extension state contexts
|`CXU_LATENCY` |latency (clock cycles) from a request to its response
|`CXU_RESET_LATENCY` |minimum latency (clock cycles) from negation of reset to first request
|===

For `CXU_LI_VERSION`, `CXU_N_CXUS`, and `CXU_N_STATES`, see ยง<<parameters>>.

`CXU_LATENCY`, specific to CXU-L1, configures the CXU latency, which
is the number of clock cycles from receiving a request to sending a
response, of every custom function implemented by the CXU. `CXU_LATENCY=0`
configures the CXU to respond to the request in the same clock cycle.

A CFI-L1 CXU with `CXU_LATENCY=0` resembles a CXU-L0 combinational
CXU, except it may implement a stateful composable extension.

[TIP]
====
Example: an extended precision arithmetic CXU which implements
`add_save_carry` and `add_with_carry_save_carry` CF instructions. Like
an ALU, this has zero cycle latency, but supports additional state
context(s), each with a carry bit.
====

`CXU_RESET_LATENCY`, specific to CXU-L1, configures the CXU reset latency,
which is the minimum number of clock cycles from negation of `rst`
to first assertion of `req_valid`. `CXU_RESET_LATENCY=0` configures
the CXU to be ready for a CXU request in the same cycle that `rst`
is first negated.

==== CXU-L1 signals

.CXU-L1 signals
[width="100%",cols="11%,25%,28%,36%",options="header",]
|===
^|*Dir* |*Port* |*Width Parameter* |*Description*
^|in |`clk` | |clock
^|in |`rst` | |reset
^|in |`clk_en` | |clock enable
^|in |`req_valid` | |request valid
^|in |`req_cxu` |`CXU_CXU_ID_W` |request <<CXU_ID,CXU_ID>>
^|in |`req_state` |`CXU_STATE_ID_W` |request <<STATE_ID,STATE_ID>>
^|in |`req_func` |`CXU_FUNC_ID_W` |request <<FUNC_ID,FUNC_ID>>
^|in |`req_data0` |`CXU_DATA_W` |request operand data 0
^|in |`req_data1` |`CXU_DATA_W` |request operand data 1
^|out |`resp_valid` | |response valid
^|out |`resp_status` |`CXU_STATUS_W` |response status
^|out |`resp_data` |`CXU_DATA_W` |response data
|===

==== CXU-L1 signaling protocol

CXU-L1 is (mostly) synchronous to posedge `clk` when `CXU_LATENCY>0`. See
ยง<<clocking>>.

Protocol:

[arabic]
. Request transfer.
[loweralpha]
.. Requester asserts CXU request signals `req_*` and asserts `req_valid`.
.. `CXU_LATENCY=0`: CXU receives CXU request asynchronously. +
`CXU_LATENCY>0`: CXU receives CXU request on posedge `clk`.
. Custom function execution.
[loweralpha]
.. CXU performs response status / error checking per ยง<<error-checking>>.
.. CXU performs a function of the operands and the selected state context.
.. CXU may update the selected state context, logically prior to any updates from subsequent requests.
. Response transfer.
[loweralpha]
.. `CXU_LATENCY=0`:
[lowerroman]
... CXU asserts CXU response signals `resp_valid`, `resp_status`, and `resp_data` asynchronously.
... Requester receives CXU response asynchronously.
.. `CXU_LATENCY>0`:
[lowerroman]
... After (`CXU_LATENCY-1`) cycles, CXU asserts `resp_valid`, `resp_status`, and `resp_data`.
... Requester receives CXU response on posedge `clk`.

==== CXU-L1 example

[[cxu-l1-wave]]
.Example CXU-L1 signaling protocol waveform (`CXU_LATENCY=2`, `CXU_RESET_LATENCY=0`)
[wavedrom,target="cxu-l1",svg]
....
{signal: [
{    name: 'clk',         wave: 'P......|....'},
{    name: 'rst',         wave: '10.....|....'},
{    name: 'clk_en',      wave: '01....0|1...'},
['Request',
{  name: 'req_valid',   wave: '01.0.1.|.0..' },
{  name: 'req_cxu',     wave: 'x34x.56|.x..', data: 'u0 u0 u0 u0' },
{  name: 'req_state',   wave: 'x34x.56|.x..', data: 's0 s0 s2 s2'  },
{  name: 'req_func',    wave: 'x34x.56|.x..', data: 'f0 f1 f2 f3' },
{  name: 'req_data0',   wave: 'x34x.56|.x..', data: 'a0 a1 a2 a3' },
{  name: 'req_data1',   wave: 'x34x.56|.x..', data: 'b0 b1 b2 b3' },
],
['Response',
{  name: 'resp_valid',  wave: '0..1.0.|.1.0' },
{  name: 'resp_status',  wave: 'x..34x.|.56x', data: 'ok err1 ok ok' },
{  name: 'resp_data',   wave: 'x..34x.|.56x', data: 'res0 0 res2 res3' },
]],
head:{
tick:'0 1 2 3 4 5 6 7 20 21 22 23 24 25 '
},
foot:{
tock:'0 1 2 3 4 5 6 7 20 21 22 23 24 25'
},}
....

<<cxu-l1-wave>> is an example waveform for four CXU-L1 CXU requests and
responses, arising from executing four custom function instructions `f0`-`f3`. Since
`CXU_RESET_LATENCY=0`, the CXU is ready for request `f0` in cycle 1, the
same cycle `rst` is negated. With `CXU_LATENCY=2`, each response occurs 2
(enabled) clock cycles after each request is received. Each instruction
issues a CXU request to the same CXU `u0`. Instructions `f0` and `f1` use
state context s0; `f2` and `f3` use state context `s2`. Request `f1` results
in an error response. With `clk_en` negated in cycles 6-19, the CXU is
frozen until cycle 20, when it finally receives the `f3` request. The `f2`
response, otherwise due in cycle 7, is also delayed, until cycle 21.

=== CXU-L2 variable latency CXU signaling

A variable latency CXU computes a function of a CXU request and the specified
state context, if any, updating the context, sending a CXU response,
in order, in a later clock cycle. There is *request and response flow
control* so the CXU can suspend receiving requests and the requester
can suspend receiving responses.

[TIP]
====
When the requester is a CPU, use of CXU-L2 allows the CPU to delay receipt
of a CXU response. This affords the CPU pipeline greater flexibility
to dynamically prioritize other units' accesses to register file write
port(s). Conversely, CXU-L2 can complicate design of a CXU, which may
have to respond to negated `resp_ready` by buffering the response in an
output FIFO or by applying back pressure through its processing pipeline,
or negate `req_ready` to delay receipt of new requests.
====

==== CXU-L2 configuration parameters

.CXU-L2 configuration parameters
[width="100%",cols="34%,66%",options="header",]
|===
|*Parameter* |*Description*
|`CXU_LI_VERSION` |CXU-LI version number
|`CXU_N_CXUS` |number of CXUs at/below this CXU
|`CXU_N_STATES` |number of composable extension state contexts
|===

For `CXU_LI_VERSION`, `CXU_N_CXUS`, and `CXU_N_STATES`, see ยง<<parameters>>.

==== CXU-L2 signals

.CXU-L2 signals
[width="100%",cols="11%,24%,27%,38%",options="header",]
|===
^|*Dir* |*Port* |*Width Parameter* |*Description*
^|in |`clk` | |clock
^|in |`rst` | |reset
^|in |`clk_en` | |clock enable
^|in |`req_valid` | |request valid
^|out |`req_ready` | |request ready
^|in |`req_cxu` |`CXU_CXU_ID_W` |request <<CXU_ID,CXU_ID>>
^|in |`req_state` |`CXU_STATE_ID_W` |request <<STATE_ID,STATE_ID>>
^|in |`req_func` |`CXU_FUNC_ID_W` |request <<FUNC_ID,FUNC_ID>>
^|in |`req_insn` |`CXU_INSN_W` |request raw instruction
^|in |`req_data0` |`CXU_DATA_W` |request operand data 0
^|in |`req_data1` |`CXU_DATA_W` |request operand data 1
^|out |`resp_valid` | |response valid
^|in |`resp_ready` | |response ready
^|out |`resp_status` |`CXU_STATUS_W` |response status
^|out |`resp_data` |`CXU_DATA_W` |response data
|===

==== CXU-L2 signaling protocol

CXU-L2 is synchronous to posedge `clk`. See ยง<<clocking>>.
CXU-L2 includes the request's raw instruction. See ยง<<raw-insn>>.

Protocol:

[arabic]
. Request transfer.
[loweralpha]
.. Requester asserts CXU request signals `req_*` and asserts `req_valid`.
.. Responder may assert `req_ready`.
.. CXU receives CXU request on posedge `clk` when `req_valid` and `req_ready` are both asserted, per ยง<<flow-control>>.
. Custom function execution.
[loweralpha]
.. CXU performs response status / error checking per ยง<<error-checking>>.
.. CXU performs a function of the operands and the selected state context.
.. CXU may update the selected state context, logically prior to any updates from subsequent requests.
. Response transfer.
[loweralpha]
.. Prior to issuing responses from subsequent requests (i.e., in order of requests) CXU asserts `resp_status` and `resp_data` and asserts `resp_valid`.
.. Requester may assert `resp_ready`.
.. Requester receives CXU response on posedge `clk` when `resp_valid` and `resp_ready` are both asserted, per ยง<<flow-control>>.

==== CXU-L2 example

<<cxu-l2-wave>> is an example waveform for four CXU-L2 CXU requests and
responses, arising from executing four CF instructions `f0`-`f3`. (Assume
`CXU_INSN_W=0`, no `req_insn`.) Each instruction issues a CXU request
to the same CXU `u0`. Instructions `f0` and `f1` use state context `s0`;
`f2` and `f3` use state context `s2`.

[[cxu-l2-wave]]
.Example CXU-L2 signaling protocol waveform
[wavedrom,target="cxu-l2",svg]
....
{signal: [
{    name: 'clk',         wave: 'P........|...'},
{    name: 'rst',         wave: '10.......|...'},
{    name: 'clk_en',      wave: '01.......|...'},
['Request',
{  name: 'req_valid',   wave: '0.1..01.0|10.' },
{  name: 'req_ready',   wave: '0.1010.1.|...'  },
{  name: 'req_cxu',     wave: 'x.34.x5.x|6x.', data: 'u0 u0 u0 u0' },
{  name: 'req_state',   wave: 'x.34.x5.x|6x.', data: 's0 s0 s2 s2'   },
{  name: 'req_func',    wave: 'x.34.x5.x|6x.', data: 'f0 f1 f2 f3' },
{  name: 'req_data0',   wave: 'x.34.x5.x|6x.', data: 'a0 a1 a2 a3' },
{  name: 'req_data1',   wave: 'x.34.x5.x|6x.', data: 'b0 b1 b2 b3' },
],
['Response',
{  name: 'resp_valid',  wave: '0..10.1.0|1.0' },
{  name: 'resp_ready',  wave: '0.1.0..1.|...' },
{  name: 'resp_status',  wave: 'x..3x.4.x|56x', data: 'ok err1 ok ok' },
{  name: 'resp_data',   wave: 'x..3x.4.x|56x', data: 'res0 res1 res2 res3' },
]
],
head:{
tick:'0 1 2 3 4 5 6 7 8 20 21 22 23 24 25'
},
foot:{
tock:'0 1 2 3 4 5 6 7 8 20 21 22 23 24'
},}
....

The CXU receives request `f0` in cycle 2 and responds in cycle 3.

Requester asserts request `f1` in cycle 3, but it is not received by
the CXU until it asserts `req_ready` in cycle 4. The CXU sends the `f1`
response in cycle 6, an error response, a latency of 2 cycles. Requester
asserts `resp_ready` and receives the response in cycle 7.

Requester asserts request `f2` in cycle 6, but it is not received by
the CXU until it asserts `req_ready` in cycle 7. The CXU responds to
`f2` in cycle 21, a latency of 14 cycles.

Requester asserts request `f3` in cycle 21, and the CXU responds in
cycle 22.

=== CXU-L3 reordering CXU signaling

A reordering CXU computes a function of the CXU request and the specified
state context, if any, updating the context, and sending a CXU response
in a later clock cycle. *Responses for requests with the same context
are sent in order, otherwise may be sent out of order*. There is request
and response flow control.

CXU-L3 incorporates a <<req-resp-id,request-response ID>> for the
requester to correlate responses received to requests sent.

[TIP]
====
This CXU-LI feature level is motivated by past experience building
floating point CXUs. Different functions, e.g., comparison, conversion,
multiplication, addition, division, and square root, exhibit a wide range
of latencies. Some functions, e.g. addition and multiplication, may be
pipelined and afford an initiation interval II=1/cycle, while others,
e.g. division and square root, may be variable latency and perform one
request at a time.

Particularly when a composable extension is stateless and when the requester
(e.g., an in-order-issue/out-of-order completion CPU) tolerates out
of order responses, response reordering can improve performance and
simplify CXU logic by reducing average CXU latency, enabling greater
CXU parallelism, and reducing request blocking and response queueing.
====

[TIP]
====
When a composable extension is stateful, response reordering cannot occur
for any sequence of requests with the same state context, to ensure
identical response data and program behavior over time and over different
CXU implementations of the same composable extension.
====

==== CXU-L3 configuration parameters

.CXU-L3 configuration parameters
[width="100%",cols="34%,66%",options="header",]
|===
|*Parameter* |*Description*
|`CXU_LI_VERSION` |CXU-LI version number
|`CXU_N_CXUS` |number of CXUs at/below this CXU
|`CXU_N_STATES` |number of composable extension state contexts
|===

For `CXU_LI_VERSION`, `CXU_N_CXUS`, and `CXU_N_STATES`, see
ยง<<parameters>>.

==== CXU-L3 signals

.CXU-L3 signals
[width="100%",cols="11%,24%,27%,38%",options="header",]
|===
^|*Dir* |*Port* |*Width Parameter* |*Description*
^|in |`clk` | |clock
^|in |`rst` | |reset
^|in |`clk_en` | |clock enable
^|in |`req_valid` | |request valid
^|out |`req_ready` | |request ready
^|in |`req_id` |`CXU_REQ_ID_W` |request <<REQ_ID,REQ_ID>>
^|in |`req_cxu` |`CXU_CXU_ID_W` |request <<CXU_ID,CXU_ID>>
^|in |`req_state` |`CXU_STATE_ID_W` |request <<STATE_ID,STATE_ID>>
^|in |`req_func` |`CXU_FUNC_ID_W` |request <<FUNC_ID,FUNC_ID>>
^|in |`req_insn` |`CXU_INSN_W` |request raw instruction
^|in |`req_data0` |`CXU_DATA_W` |request operand data 0
^|in |`req_data1` |`CXU_DATA_W` |request operand data 1
^|out |`resp_valid` | |response valid
^|in |`resp_ready` | |response ready
^|out |`resp_id` |`CXU_REQ_ID_W` |response ID
^|out |`resp_status` |`CXU_STATUS_W` |response status
^|out |`resp_data` |`CXU_DATA_W` |response data
|===

==== CXU-L3 signaling protocol

CXU-L3 is synchronous to posedge `clk`. See ยง<<clocking>>.
CXU-L3 includes a request-response ID. See ยง<<req-resp-id>>.
CXU-L3 includes the request's raw instruction. See ยง<<raw-insn>>.

Protocol:

[arabic]
. Request transfer.
[loweralpha]
.. Requester asserts CXU request signals `req_*` (including new CXU-L3 signal `req_id`) and asserts `req_valid`.
.. Responder may assert `req_ready`.
.. CXU receives CXU request on posedge `clk` when `req_valid` and `req_ready` are both asserted, per ยง<<flow-control>>
. Custom function execution.
[loweralpha]
.. CXU performs response status / error checking per ยง<<error-checking>>.
.. CXU performs a function of the operands and the selected state context.
.. CXU may update the selected state context, logically prior to any updates _to the same state context_ from subsequent requests.
. Response transfer.
[loweralpha]
.. Prior to issuing responses from subsequent requests _to the same state context_ (i.e., in order of requests to the same state context) CXU asserts `resp_id`, `resp_status`, `resp_data` and asserts `resp_valid`.
.. Requester may assert `resp_ready`.
.. Requester receives CXU response on posedge `clk` when `resp_valid` and `resp_ready` are both asserted, per ยง<<flow-control>>.

==== CXU-L3 example

<<cxu-l3-wave>> is an example waveform for four CXU-L3 CXU requests,
illustrating two different valid out-of-order response sequences, arising
from executing four CF instructions `f0`-`f3`. (Assume `CXU_INSN_W=0`,
no `req_insn`.) Each instruction issues a CXU request to the same CXU
`u0`, but with various state contexts `s0`, `s1`, `s0` (again), and
`s3`. This constrains the CXU to respond to request `f0` with state
`s0`, before responding to subsequent request `f2` for state `s0`.

Note that each CXU request is tagged with a `req_id`, a value that is returned
by the CXU with the corresponding `resp_id`, and used by the requester to
correlate responses to requests and recover the reordering as necessary.

[[cxu-l3-wave]]
.Example CXU-L3 signaling protocol waveform, with two of the possible response orderings
[wavedrom,target="cxu-l3",svg]
....
{signal: [
{    name: 'clk',         wave: 'P..........'},
{    name: 'rst',         wave: '10.........'},
{    name: 'clk_en',      wave: '01.........'},
['Request',
{  name: 'req_valid',   wave: '0.1...0....' },
{  name: 'req_ready',   wave: '0.1........'  },
{  name: 'req_id',      wave: 'x.3456x....', data: 'id0 id1 id2 id3' },
{  name: 'req_cxu',     wave: 'x.3456x....', data: 'u0 u0 u0 u0' },
{  name: 'req_state',   wave: 'x.3456x....', data: 's0 s1 *s0 s3'   },
{  name: 'req_func',    wave: 'x.3456x....', data: 'f0 f1 f2 f3' },
{  name: 'req_data0',   wave: 'x.3456x....', data: 'a0 a1 a2 a3'  },
{  name: 'req_data1',   wave: 'x.3456x....', data: 'b0 b1 b2 b3'  },
],
['Response',
{  name: 'resp_valid',  wave: '0...101.010' },
{  name: 'resp_ready',  wave: '0.1........' },
{  name: 'resp_id',     wave: 'x...4x63x5x', data: 'id1 id3 id0 id2'   },
{  name: 'resp_status',  wave: 'x...4x63x5x', data: 'ok ok ok ok'  },
{  name: 'resp_data',   wave: 'x...4x63x5x', data: 'res1 res3 res0 res2'   },
],
{},
['Another Ordering',
{  name: 'resp_valid',  wave: '0.....1...0' },
{  name: 'resp_ready',  wave: '0.1........' },
{  name: 'resp_id',     wave: 'x.....6354x', data: 'id3 id0 id2 id1'   },
{  name: 'resp_status',  wave: 'x.....6354x', data: 'ok ok ok ok'  },
{  name: 'resp_data',   wave: 'x.....6354x', data: 'res3 res0 res2 res1'   },
]
],
head:{ tick:'0' },
foot:{ tock:'0' },
}
....

In the first example response, with signals labeled _Response_, the
CXU receives requests (`f0`, `f1`, `f2`, `f3`) but responds in order
(`f1`, `f3`, `f0`, `f2`). In the second example response, with signals
labeled _Another Ordering_, the CXU responds in order (`f3`, `f0`,
`f2`, `f1`). Bother orderings are valid because they preserve the order
`f0`<`f2` caused by these two CXU requests using the same state `s0`.

=== CXU feature level adapters

A CXU feature level adapter is an intermediary CXU that receives requests
and sends responses at one CXU-LI feature level and adapts them for and
forwards them to a subordinate CXU at a lower CXU-LI feature level.

CXU-LI includes a set of configurable adapters to raise any CXU to any
higher feature level, easing composition:

* `Cvt01`: raise L0 to L1: add configurable latency pipelining
* `Cvt02`, `Cvt12`: raise L0 or L1 to L2: add request-response flow control (may suspend requests)

[NOTE]
====
TODO: Describe the L3 adapters, which are just L2 adapters with a
<<req-resp-id,request-response ID>> FIFO.
====

==== `Cvt01`: raise CXU-L0 to CXU-L1

A `Cvt01` adapter CXU implements CXU-L1, including its configuration
parameters (ยง<<_cxu_l1_configuration_parameters>>), adapting L1 requests
to and responses from a subordinate combinational L0 CXU.

When `CXU_LATENCY=0`, the adapter's request/response channels are directly
coupled to the subordinate CXU request/response channels. Otherwise,
these channels I/Os are registered and pipelined, with a total latency of
`CXU_LATENCY` cycles.

[TIP]
====
Automatic pipeline retiming may _slice_ the combinational logic cone
into several pipeline stages, achieving higher frequency operation.
====

==== `Cvt02`: raise CXU-L0 to CXU-L2

A `Cvt02` adapter CXU implements CXU-L2, including its configuration
parameters (ยง<<_cxu_l2_configuration_parameters>>), adapting L2 requests
to and responses from a subordinate combinational L0 CXU. The adapter
has a fixed latency of one cycle -- a response is sent one cycle after
a request is received.

[TIP]
====
To avoid arbitrary CXU response queuing, yet keep signaling simple and
frugal, the `Cvt02` adapter might negate `req_ready` on any cycle that it
has a valid response waiting (asserting `resp_valid`) and the requester
negates `resp_ready`.
====

==== `Cvt12`: raise CXU-L1 to CXU-L2

A `Cvt12` adapter CXU implements CXU-L2, including its configuration
parameters (ยง<<_cxu_l2_configuration_parameters>>), plus `CXU_LATENCY`
(ยง<<_cxu_l1_configuration_parameters>>), adapting L2 requests to and
responses from a subordinate fixed latency L1 CXU.

The `CXU_LATENCY` parameter, which specifies the latency of the
_subordinate L1 CXU_, typically configures the depth of a response
FIFO -- an entire response stream must be buffered when the requester,
having just issued `CXU_LATENCY` of requests to the L1 CXU, negates
`resp_ready` through as many clock cycles. Eventually, with response
transfers paused, the response FIFO fills and the adapter CXU negates
`req_ready`.

When `CXU_LATENCY=0`, the subordinate CXU response must be registered
and therefore the adapter's response latency is at least one cycle.

[[cpus]]
=== CXU-LI-compliant CPUs

A CXU-LI-compliant CPU implements RISC-V RV-I -Zicsr + _(CX-ISA
extension)_ instruction set, sends CXU requests upon issuing custom
operation instructions, and writes a destination register and CX status
CSR in response to CXU responses.

==== CPUs and CXU-LI feature levels

CPUs, as CXU requesters, use specific CXU-LI feature levels.

[TIP]
====
An austere single-cycle CPU might use CXU-L0 with a combinational CXU
(only).

A pipelined in-order CPU might use CXU-L1 with a fixed latency CXU
configured for (e.g.) 2 cycles latency. It might also use CXU-L2 with
a variable latency CXU, stalling the pipeline during cycles where CF
instructions cannot issue because the selected CXU negates `req_ready`,
and itself negating `resp_ready` during write-back cycles when the
register file's write port or other necessary resource is unavailable.

An out-of-order completion CPU, i.e. one that may commit low latency
instructions before prior high latency instructions, might issue CF
instructions to a CXU-L2 variable latency CXU and in some future cycle
retire the variable latency CXU response, here again negating `resp_ready`
when it is unable to accept a response to writeback.

An OoO completion CPU, that handles reordered CXU responses, might use
a CXU-L3 reordering CXU.
====

A CPU may have one or more sets of CXU request and response ports. For each
such set, a CPU may send zero or one CXU request per cycle and receive
zero or one CXU response per cycle.

[TIP]
====
Most CPUs send up to one request and receive up to one response. However,
a CXU-LI compliant superscalar CPU might send multiple CXU requests
and receive multiple CXU responses, to multiple CXUs of the same, or
different, CXU-LI feature levels, in parallel, in the same cycle.
====

=== Example: CXU signaling in a composed system

Consider <<switch22>>, a system composed from two single-hart CPUs, two
stateful CXUs, and a 2-input, 2-output Switch CXU. Fixed latency CXU~0~
implements CXU-L1, configured with `CXU_LATENCY=1`. The CPUs, CXU~1~,
and `Switch22` use/implement CXU-L2. `Cvt12`, a CXU level converter,
up-converts CXU~0~ from CXU-L1 to CXU-L2.

[[switch22]]
.CXU-L2 system, with two CPUs, switch CXU, converter CXU, CXU~0~ (L1), and CXU~1~ (L2)
image::cxu-switch22.png[image,width=400]

With one hart per CPU, the composable extensions' CXUs are configured
with two state contexts each (<2>).

Both CPU~0~ and CPU~1~ are configured to issue CF instructions mapping
CX_ID~0~ -> CXU_ID=0 -> CXU~0~ and CX_ID~1~ -> CXU_ID=1 -> CXU~1~.

The exemplary 2x2 Switch CXU is frugal, if low frequency, while sustaining
one cycle initiation interval transfers of requests and responses. It
multiplexes downstream request transfers and upstream response
transfers. In both directions, the switch consists of input ports (not
registered), output port registers, an approximately fair output port
arbiter, and a 2x2 channel crossbar. Each cycle, the switch determines
which output ports are _available_ (i.e., are empty, or will transfer
(`valid & ready`) this cycle) and which valid inputs are _eligible_
to transfer, then asserts ready, and transfers, some eligible inputs to
available output ports, based upon a rotating priority order.

A _request_ input port is eligible to transfer if it is valid and if
the target `req_cxu` CXU_ID is the same as the last request, or if there
are no pending responses for this port. This ensures that responses for
requests, routed to different CXUs with different latencies, are always
returned in order to the requester, as required by CXU-L2.

Downstream request routing is per the request inputs' `req_cxu` elements:
CXU_ID=0 routes to the first output port and CXU_ID=1 routes to the
second output port. The switch itself responds to requests with invalid
CXU_IDs with a `CXU_ERROR_CXU` response.

For upstream response routing, the Switch incorporates, for each subordinate
CXU, a FIFO queue that records the requester port ID that issued each
request to that CXU. As each (in order) response from that CXU is
received, the requester port ID is dequeued from that FIFO and used to
route the response to its corresponding requester.

In this example, assume each CPU decouples issue and commit using
a scoreboarded register file enabling arbitrary extension unit
latencies. Each CPU runs the same code (<<cim3>>):

[arabic]
. Write `mcx_selector` for CXU_ID=0 and STATE_ID=__HART_ID__, issue two CF instructions to CXU~0~;
. Write `mcx_selector` for CXU_ID=1 and STATE_ID=__HART_ID__, issue two CF instructions to CXU~1~;
. Write `mcx_selector` for CXU_ID=0 and STATE_ID=__HART_ID__, issue one CF instruction to CXU~0~.

[[cim3]]
.Issue stateful CF instructions `f0` and `f1` to CXU~0~, `f2` and `f3` to CXU~1~, and `f4` to CXU~0~ again.
[source,asm]
....
csrw mcx_selector,x20   ; version=1, cxe=0, CXU_ID=0, STATE_ID=HART_ID
cx_reg 0,x3,x1,x2       ; u0.f0
cx_reg 1,x6,x5,x4       ; u0.f1

csrw mcx_selector,x21   ; version=1, cxe=0, CXU_ID=1, STATE_ID=HART_ID
cx_reg 2,x9,x7,x8       ; u1.f2
cx_reg 3,x12,x11,x10    ; u1.f3

csrw mcx_selector,x20   ; version=1, cxe=0, CXU_ID=0, STATE_ID=HART_ID again
cx_reg 4,x15,x13,x14    ; u0.f4
....

<<switch22-wave>> is an example waveform executing <<cim3>>
near-simultaneously on the two CPUs of <<switch22>>.

(_1:u2<3>.f4_ denotes CXU request #1 with CXU_ID=2 STATE_ID=3 FUNC_ID=4)

In the narrative that follows, that _A sends B_ means _A asserts B
ahead of next posedge `clk`,_ whereas _B transfers to C_ means _during
this cycle C receives and accepts it_. Recall with CXU-L2, request
transfers occur when both `req_valid` and `req_ready` are asserted
(ยง<<flow-control>>), and response transfers occur when `resp_valid`
and `resp_ready` are asserted.

[[switch22-wave]]
.Example 2-input 2-output CXU-L2 Switch CXU signaling protocol waveform
[wavedrom,target="cxu-2x2",svg]
....
{signal: [
{    name: 'clk',       wave: 'P..................'},
['CPU-0',
{  name: 'req_valid',   wave: '01..01...01...0....' },
{  name: 'req_ready',   wave: '010101010....10....'  },
{  name: 'req_*',       wave: 'x23.x45.x2....x....', data: '0:u0 1:u0<0>.f1 2:u1 3:u1<0>.f3 4:u0<0>.f4' },
{  name: 'resp_*',      wave: 'x.x.2x3x4x...5x.2x.', data: '0:ok 1:ok 2:ok 3:ok 4:ok' },
],
{},
['CPU-1',
{  name: 'req_valid',   wave: '01...01...01...0...' },
{  name: 'req_ready',   wave: '0.101010.10...10...'  },
{  name: 'req_*',       wave: 'x6.7.x89..x6...x...', data: '5:u0<1> 6:u0<1>.f1 7:u1 8:u1<1>.f3 9:u0<1>.f4' },
{  name: 'resp_*',      wave: 'x..x.6x7x.8x..9x.6x', data: '5:ok 6:ok 7:ok 8:ok 9:ok' },
],
{},
['CXU-0',
{  name: 'req_valid',   wave: '0.1...0.......1.0..' },
{  name: 'req_ready',   wave: '01.................'  },
{  name: 'req_*',       wave: 'x.2637x.......26x..', data: '0:u0 5:u0 1:u0 6:u0 4:u0 9:u0' },
{  name: 'resp_*',      wave: 'x..2637x.......26x.', data: '0:ok 5:ok 1:ok 6:ok 4:ok 9:ok' },
],
{},
['CXU-1',
{  name: 'req_valid',   wave: '0.....1......0.....' },
{  name: 'req_ready',   wave: '01......010.1......'  },
{  name: 'req_*',       wave: 'x.....485.9..x.....', data: '2:u1 7:u1 3:u1<0>.f3 8:u1<1>.f3' },
{  name: 'resp_*',      wave: 'x......4x8x.59x....', data: '2:u1 7:u1 3:u1 8:u1' },
],
],
head:{ tick:'0' },
foot:{ tock:'0'
}
}
....

Cycle-by-cycle:

[arabic,start=0]
. Both CPUs CSR-write their hart's `mcx_selector` registers, selecting CXU_ID=0=CXU~0~, and their hart's STATE_ID. +
Both CPUs issue the first CF instruction (`f0`).

[arabic,start=0]
. CPU~0~ sends first CXU request (request #0): CXU_ID=0 STATE_ID=0 FUNC_ID=0, a.k.a. `0:u0<0>.f0`. +
CPU~1~ sends first CXU request (request #5): CXU_ID=0 STATE_ID=1 FUNC_ID=0, a.k.a. `5:u0<1>.f0`.
. CPU~0~'s first request, destined for CXU~0~, wins arbitration for Switch output port 0. +
Switch asserts CPU~0~'s `req_ready` and negates CPU~1~'s `req_ready`. +
CPU~0~'s first request `0:u0<0>.f0` transfers to Switch. +
Switch sends CPU~0~'s first request to `Cvt12(CXU~0~)` +
CPU~0~ sends second CXU request: `1:u0<0>.f1`.
. CPU~1~'s first request, destined for CXU~0~, wins arbitration for Switch output port 0. +
Switch asserts CPU~1~'s `req_ready` and negates CPU~0~'s `req_ready`. +
CPU~1~'s first request `5:u0<1>.f0` transfers to Switch. +
Switch sends CPU~1~'s first request to `Cvt12(CXU~0~)`. +
CPU~1~ sends second CXU request: `6:u0<0>.f1`. +
CPU~0~'s first request `0:u0<0>.f0` transfers to CXU~0~. +
CXU~0~ executes `0:f0`, updates state `<0>`, sends response to Switch.
. CPU~0~ sends no CXU request this cycle, due to its second `csrw` execution cycle. +
CPU~0~'s second request `1:u0<0>.f1`, wins arbitration, transfers to Switch, is sent to `Cvt12(CXU~0~)`. +
CPU~1~'s first request `5:u0<1>.f0` transfers to CXU~0~, executes, updates `<1>`, sends response to Switch. +
CXU~0~'s response to CPU~0~'s first request transfers to Switch, is sent to CPU~0~.
. CPU~1~ sends no CXU request this cycle, due to its second `csrw` execution cycle. +
CPU~1~'s second request `6:u0<0>.f1`, wins arbitration, transfers to Switch, is sent to `Cvt12(CXU~0~)`. +
CPU~0~'s second request `1:u0<1>.f1` transfers to CXU~0~, executes, updates `<0>`, sends response to Switch. +
CXU~0~'s response to CPU~1~'s first request transfers to Switch, is sent to CPU~1~. +
CXU~0~'s response to CPU~0~'s first request transfers to CPU~0~.
. CPU~0~ bubble in CXU request issue due to its second `csrw` execution cycle. +
CPU~1~ sends third request `2:u1<1>.f2`, with CXU_ID=1, destined for CXU~1~. +
CPU~0~'s third request `2:u1<0>.f2`, transfers to Switch, is sent to CXU~1~. +
CPU~0~ sends fourth request `3:u1<0>.f3`, with CXU_ID=1, destined for CXU~1~. +
CPU~1~'s second request `6:u0<1>.f1` transfers to CXU~0~, executes, updates `<1>`, sends response to Switch. +
CXU~0~'s response to CPU~0~'s second request transfers to Switch, is sent to CPU~0~. +
CXU~0~'s response to CPU~1~'s first request transfers to CPU~1~.
. CPU~1~'s third request `7:u1<0>.f2` wins arbitration, transfers to Switch, is sent to CXU~1~. +
CPU~1~ sends fourth request `8:u1<0>.f3`, with CXU_ID=1, destined for CXU~1~. +
CPU~0~'s third request `2:u1<0>.f2` transfers to CXU~1~, executes, updates `<0>`, sends response to Switch. +
CXU~0~'s response to CPU~1~'s second request transfers to Switch, is sent to CPU~1~. +
CXU~0~'s response to CPU~0~'s second request transfers to CPU~0~.
. CPU~0~ sends no CXU request this cycle, due to its third `csrw` execution cycle. +
CPU~0~'s fourth request `3:u1<0>.f3` wins arbitration, transfers to Switch, is sent to CXU~1~. +
CPU~1~'s third request `7:u1<1>.f2` transfers to CXU~1~, begins execution. +
CXU~1~'s response to CPU~0~'s third request transfers to Switch, is sent to CPU~0~. +
CXU~0~'s response to CPU~1~'s second request transfers to CPU~1~.
. CPU~1~ sends no CXU request this cycle, due to its third `csrw` execution cycle. +
CPU~0~ sends fifth request `4:u0<0>.f4`, with CXU_ID=0, destined for CXU~0~. +
At CXU~1~, CPU~1~'s third request `7:u1<0>.f2` completes execution, updates `<1>`, sends response to Switch. +
CXU~1~'s response to CPU~0~'s third request transfers to CPU~0~.
. CPU~0~'s fifth CXU request is _ineligible_ to transfer because CPU~0~ has pending requests to CXU~1~. It becomes eligible at cycle 13. +
CPU~1~'s fourth request `8:u1<0>.f3` transfers to Switch, is sent to CXU~1~. +
CPU~0~'s fourth request `3:u1<0>.f3` transfers to CXU~1~, begins execution. +
CXU~1~'s response to CPU~1~'s third request transfers to Switch, is sent to CPU~1~.
. CPU~1~ sends fifth request `9:u0<1>.f4`, with CXU_ID=0, destined for CXU~0~. +
CPU~0~'s fourth CXU request `3:u1<0>.f3` continues execution. +
CXU~1~'s response to CPU~1~'s third request transfers CPU~1~.
. CPU~1~'s fifth CXU request is _ineligible_ to transfer because CPU~1~ has pending requests to CXU~1~. It becomes eligible at cycle 14. +
CPU~0~'s fourth CXU request `3:u1<0>.f3` completes execution, updates `<0>`, sends response to Switch.
. CPU~1~'s fourth request `8:u1<1>.f3` transfers to CXU~1~, executes, updates `<1>`, sends response to Switch. +
CXU~1~'s response to CPU~0~'s fourth request transfers to Switch, is sent to CPU~0~.
. CXU~1~'s response to CPU~0~'s fourth request transfers to CPU~0~. +
CPU~0~'s fifth request `4:u0<0>.f4` becomes eligible, transfers to Switch, is sent to CXU~0~.
. CXU~1~'s response to CPU~1~'s fourth request transfers to CPU~1~. +
CPU~1~'s fifth request `9:u0<1>.f4` becomes eligible, transfers to Switch, is sent to CXU~1~. +
CPU~0~'s fifth request `4:u0<0>.f4` transfers to CXU~0~, executes, updates `<0>`, sends response to Switch.
. CPU~1~'s fifth request `9:u0<1>.f4` transfers to CXU~0~, executes, updates `<1>`, sends response to Switch. +
CXU~0~'s response to CPU~0~'s fifth request transfers to Switch, is sent to CPU~0~.
. CXU~0~'s response to CPU~1~'s fifth request transfers to Switch, is sent to CPU~1~. +
CXU~0~'s response to CPU~0~'s fifth request transfers to CPU~0~.
. CXU~0~'s response to CPU~1~'s fifth request transfers to CPU~1~.

=== Composing CXUs with AXI4-Streams

In some configured systems, preexisting infrastructure components
that implement AXI4-Stream protocol may be used to help compose CPUs
and CXUs. A fully flow controlled CXU-LI -L2 or -L3 transfer may be
transported over two AXI4-Stream (AXI-S) streams, one for requests and
one for responses.

[TIP]
====
For example, in a AMD/Xilinx Versal FPGA, a CPU might transfer CXU
requests, via CXU-L2-to-AXI-S bridge, AXI-S-to-NOC bridge, Versal NOC,
NOC-to-AXI-S bridge, AXI-S-to-CXU-L2 bridge, to a CXU at the far corner
of the FPGA fabric, later transferring CXU responses back to the _distant_
CPU by the same means.
====

<<cxu-axis>> presents a recommended canonical mapping between CXU-LI
signals and the two AXI-S streams.

[[cxu-axis]]
.Recommended mapping between CXU-L2/-L3 and request/response AXI4-Streams
[width="80%",cols="9%,24%,26%,41%",options="header,unbreakable"]
|===
^|*Dir* |*CXU-LI Port* |*Width* |*AXI-S Port*
^|in |`clk` | |`aclk`
^|in |`rst` | |`aresetn` _(inverted)_
^|in |`clk_en` | |-
^|in |`req_valid` | |`reqs_tvalid`
^|out |`req_ready` | |`reqs_tready`
^|in |`req_id` |`CXU_REQ_ID_W` |`reqs_tid` _or_ `reqs_tdest`
^|in |`req_cxu` |`CXU_CXU_ID_W` |`reqs_tuser` _or_ `reqs_tdest`
^|in |`req_state` |`CXU_STATE_ID_W` |`reqs_tuser`
^|in |`req_func` |`CXU_FUNC_ID_W` |`reqs_tuser`
^|in |`req_insn` |`CXU_INSN_W` |`reqs_tuser`
^|in |`req_data0` |`CXU_DATA_W` |`reqs_tdata`
^|in |`req_data1` |`CXU_DATA_W` |`reqs_tdata`
^|in |- | |`reqs_tlast` _optional_
^|in |- |* |`reqs_tstrb` _optional_
^|in |- |* |`reqs_tkeep` _optional_
^|out |`resp_valid` | |`resps_tvalid`
^|in |`resp_ready` | |`resps_tready`
^|out |`resp_id` |`CXU_REQ_ID_W` |`resps_tid` _or_ `resps_tdest`
^|out |`resp_status` |`CXU_STATUS_W` |`resps_tuser`
^|out |`resp_data` |`CXU_DATA_W` |`resps_tdata`
^|out |- | |`resps_tlast` _optional_
^|out |- |* |`resps_tstrb` _optional_
^|out |- |* |`resps_tkeep` _optional_
|===

When several CXU-LI signals map to a single AXI-S port, the signals
are to be concatenated in order, each signal assigned successively more
significant bits. For example, using Verilog concatenation:

[code,verilog]
....
reqs_tuser = { req_insn,req_func,req_state,req_cxu };
reqs_tdata = { req_data1,req_data0 };
....

Use `reqs_tdest` when `req_id` and/or `req_cxu` indicate/encode a
specific AXI-S destination (of a bridge to a CXU). Use `resps_tdest`
when of `resp_id` indicates a specific AXI-S destination (of a bridge
to a requester, e.g., CPU).

