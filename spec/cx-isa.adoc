== Composable extensions: the hardware-software interface

The Composable Extension abstraction bridges software and hardware, enabling
diverse software libraries which target the same extension and
diverse hardware CXU cores which implement the same extension. Then
_composable extension multiplexing_ enables composition of systems of
separately authored and versioned components.

=== Definitions

A *custom function (CF)* is a function from two integer operands to an
integer result and response status. May be stateless or stateful.

[[CF_ID]]
A *custom function identifier (CF_ID)* is an integer, in the scope of
a composable extension, identifying a custom function. A *valid CF_ID*
is a value that identifies a CF instruction implemented by a configured
extension.

A *stateless custom function* is a CF that is a pure function of
its operands (only). Never reads nor writes any other architected
state. Given the same operand values, always produces the same result
and response status.

A *stateful custom function* is a CF that is a function of its operands
and its composable extension state context (only). May read and write the
context but never reads or writes other architected state. Equivalently:
a CF that is a function of its operands and of any prior CF invocations
upon its composable extension (only).

A *composable extension (CX, extension)* is a fixed named set of
custom functions and custom CSRs. May be stateless or stateful. _Fixed:_
immutable, i.e., any versioning of the CFs or custom CSRs or the behavior
of an extension necessarily defines a new extension. _Named:_ has a
composable extension identifier.

[[CX_GUID]]
A *composable extension identifier (CX_ID)* is a 128-bit globally unique ID
(_GUID_) [see RFC-4122], unique in history, identifying a composable
extension.

A *stateless composable extension* is a fixed named set of set of stateless
custom functions. A stateless CX has no read-write custom CSRs but
may have read-only custom CSRs.

A *stateful composable extension* is a fixed named set of custom functions,
at least one of which is a stateful custom function, plus a set of
custom CSRs, plus a composable extension state context.

A *composable extension state context (state context, state, context)*
is an isolated collection of state associated with a stateful composable
extension. Isolated: stateful custom functions of the extension may read
and write the state context, but no other element or operation of the
system may read or write the state context.

A *CX CSR* is a custom CSR of a stateful composable extension.

[[CX_op]]
A *CX operation* is a custom opcode instruction or a custom address CSR access.

[[FUNC_ID]]
A *function ID (FUNC_ID)* is an integer, in the scope of a composable
extension, that identifies a custom operation. At present it conveys
either a <<CF_ID,CF_ID>> of a custom function instruction or a CSR access
of a custom CSR access instruction.

A *configured composable extension (configured extension)* is an extension
that is configured (included) within a system and is implemented by a
CXU of the system (a *configured CXU*). Within a system, a configured
extension has some configured number of state contexts.

A *configured extension subset* is a configured extension in which one
or more custom functions of the extension are not implemented. The CF_IDs
of unimplemented custom functions are invalid.

[[STATE_ID]]
A *composable extension state context identifier (STATE_ID)* is an integer
index, in the scope of a configured extension, in the range [0,
no. of state contexts-1] identifying one of an extension's contexts
in the system. A stateless extension has zero state contexts and uses
STATE_ID=0 whenever a STATE_ID is required. A *valid STATE_ID* is a
value that identifies a state context of a configured extension.

A *custom function instruction (CF instruction)* is a RISC-V custom
instruction that executes a custom function using a composable extension
unit, sourcing the integer operands from the register file and/or from
an immediate field of the instruction, writing the integer result to the
register file, and updating the CX status CSR with the response status.

A *composable extension unit (CXU)* is a core that implements one or more
composable extensions. A *stateful CXU* implements at least one stateful
composable extension.

[[CXU_GUID]]
A *composable extension unit identifier (CXU_GUID)* is a 128-bit globally
unique ID (_GUID_) [see RFC-4122], unique in history, identifying a
specific CXU implementation.

[[CXU_ID]]
A *CXU_ID* is an integer, in the scope of a system, that identifies
a configured extension implemented by a CXU. When one CXU implements
multiple configured extensions, different CXU_IDs identify the configured
extensions. A *valid CXU_ID* is a CXU_ID value that identifies a
configured extension.

A *composable extension selector (CX selector, selector)* is a 32-bit
value written to `mcx_selector` CSR to select the hart's current extension
multiplexing version, (e.g., _off_, _version-1_, ...), whether
_trap on custom operation_ is _enabled_, and to specify the
hart's current configured extension / CXU and current state context.

[[selector-table]]
A *CX selector table* is a 4 KB aligned, 4 KB sized table of 1024
CX selectors. When CX access control (ยง<<_cx_access_control>>) is
supported, each hart has a `mcx_table` CSR to address its CX
selector table.

A *selector index* is an integer that identifies an entry in a CX selector
table (ยง<<_cx_access_control>>).

[[cx_isa_csrs]]
=== New CX control / status registers

A CX-ISA compatible CPU shall implement the `mcx_selector` and
`cx_status` CSRs for extension multiplexing and custom function
instruction execution.

When CX access control
(ยง<<_cx_access_control>>)
is supported, a CX-ISA compatible CPU
shall implement the `mcx_table` and `cx_index` CSRs.

All CX-ISA CSR fields marked _reserved_ are WPRI, write preserve, read
ignored, and all other fields are WARL, write any/read legal values. (An
invalid <<CXU_ID,CXU_ID>> or <<STATE_ID,STATE_ID>> value is still _legal_).

All CX-ISA CSRs are initialized to zero on reset.

[[mcx_selector]]
==== `mcx_selector` CSR 0xBC0: select active CXU and state context

The `mcx_selector` CSR implements composable extension multiplexing. It
is assigned various CX selectors over time. This enables or disables
CX multiplexing and selects the hart's current CXU and state context
(within that CXU). It may only be read or written in machine level.

[NOTE]
====
In a privileged architecture system, user level read access to
`mcx_selector` values could reveal goings-on in other software threads
and thus facilitate side channel attacks.
====

[NOTE]
====
In a privileged architecture with M/S/U levels, for example, what CSRs
are required and what access permissions should they have?
====

.`mcx_selector` CSR 0xBC0 (version 0: legacy custom instructions))
[wavedrom,target="`mcx_selector_0`",svg]
....
{reg:[
{bits: 28, name: 'reserved', type:1, vspace:88},
{bits: 1, name: 'cxe'},
{bits: 3, name: 0, attr:'version'},
],
config: {lanes: 1, bits: 32}
}
....

.`mcx_selector` CSR 0xBC0 (version 1: extension multiplexing)
[wavedrom,target="`mcx_selector`",svg]
....
{reg:[
{bits: 8, name: 'cxu_id'},
{bits: 8, name: 'reserved', type:1, vspace:88},
{bits: 8, name: 'state_id'},
{bits: 4, name: 'reserved', type:1},
{bits: 1, name: 'cxe'},
{bits: 3, name: 1, attr:'version'},
],
config: {lanes: 1, bits: 32}
}
....

The `mcx_selector` CSR has the following fields:

`.version`: extension multiplexing version

* When `version=0`, disable composable extension multiplexing.
When `cxe=0`, `custom-[0123]` instructions execute the CPU's built-in
custom instructions and custom CSR addresses select the CPU's built-in
custom CSRs. When `cxe=1`, `custom-[0123]` instructions and custom CSR
accesses raise an illegal-instruction exception.

* When `version=1`, enable _version-1_ composable extension
multiplexing. The `cxu_id` and `state_id` fields select the current
CXU and state context. When `cxe=0`, `custom-[012]` instructions issue
CXU requests, and custom CSR accesses access CX CSRs, of the CXU and
state context identified by `cxu_id` and `state_id`. When `cxe=1`,
`custom-[012]` instructions and custom CSR accesses raise an illegal
instruction exception.

* `version` values 2-7 are reserved.

`.cxe`: custom operation exception enable

* When (`version=0` or `version=1`) and `cxe=1`, a custom operation
raises an illegal-instruction exception.

`.cxu_id`: select the hart's current CXU

* A valid `cxu_id` identifies a configured CXU.

* When enabled, when `cxu_id` does not identify a configured CXU,
executing a custom operation instruction causes an invalid CXU_ID
error. The `cx_status.CX` error bit is set and the instruction's
destination register, if any, is zeroed.

`.state_id`: select the hart's current CXU's current state context

* A valid `state_id` identifies a state context of a CXU.

* When enabled, when `cxu_id` is valid, but `state_id` does not identify a
state context of the current CXU, executing a custom operation instruction
causes an invalid STATE_ID error. The `cx_status.IS` error bit is set
and the custom operation instruction's destination register, if any,
is zeroed.

No error occurs when `mcx_selector` is CSR-written with an invalid
CX selector, i.e., when `.cxu_id` or `.state_id` are invalid. Rather,
subsequently executing a custom operation instruction may cause a CXU_ID
or STATE_ID error.

[TIP]
====
The hardware that detects these two errors _might not be_ implemented
by an extensible processor but rather in the CXU interconnect (bad
`.cxu_id`) or in a selected CXU (bad `.state_id`).
====

[TIP]
====
The `version` field provides backwards compatibility with legacy
custom extensions, and forwards compatibility with future CX systems.
In future a new CX multiplexing version may be added, with a new layout
and interpretation of selector fields and new means of decoding custom
instruction fields into CXU requests. With seven non-zero values, it
accomodates an additional extension multiplexing scheme every three
years for twenty years.
====

[TIP]
====
The `cxe` field enables 1) software emulation of any built-in (legacy)
custom instruction or custom CSR; 2) software emulation of any composable
extension custom instruction or custom CSR; 3) transparent virtualization
of CX state contexts; and 4) a representation of _invalid selector_
sentinel value(s) to detect use of erroneous selector indices.

An illegal-instruction trap handler can emulate any absent built-in
custom instruction or any custom instruction of a composable extension,
then return to the following instruction.

Using CX access control (ยง<<_cx_access_control>>) CSRs, an OS can
transparently _virtualize_ many logical CX state contexts on fewer
(or just one!) physical CX state contexts. When multiple CX libraries
each try to open the same (e.g., singleton) CX state context, the OS
can give each a unique CX selector index value, with all-but-one of
their corresponding CX selector table entries set `cxe=1` to trap on
first custom operation. Once such a selector index is used to select the
thread's current CX, a custom operation incurs an illegal-instruction
exception. The illegal-instruction trap handler determines which virtual
CX state context currently has the physical CX state context, saves that
CX state context, sets `cxe=1` on its selector table entry, restores the
thread's current CX's state context, clears `cxe=0` for its selector
table entry, rewrites `cx_index` with `cx_index` for the side-effect
of updating `mcx_selector` with this selector table entry value with
`cxe=0`, and returns from exception, reissuing the custom operation,
which does not trap.
====

[TIP]
====
The selector's `cxe` field is _subordinate_ to the `version` field so
that future revisions of this specification may incorporate new trap
behaviors and trap control bits.
====

The selector `0x3FFFFFFF` = `'{version:1, cxe:1, ..., state_id:0xFF, ..., cxu_id:0xFF}`
is the canonical _invalid selector_.

[TIP]
====
Typically an OS will fill unused `mcx_table[]` entries with this invalid
selector to trap first custom operation use of an invalid selector index.
====

[[cx_status]]
==== `cx_status` CSR 0x801: CX status

The `cx_status` CSR accumulates CX error flags, which include CX
multiplexing errors as well as stateless and stateful CX custom operation
errors. It may be written and read in all privilege levels.

Typical application software will write a CX selector to `mcx_selector`
(perhaps indirectly via `cx_index`), write 0 to `cx_status`, execute
some custom operation instructions, and read `cx_status` to determine
if there were any errors.

Updates to `cx_status` are precise, _as if_ each custom operation
instruction issues and completes prior to the next, even if under the hood
custom operations instructions are pipelined or complete out-of-order.

[TIP]
====
Since `cx_status` behaves like `fcsr`, it should have similar high
performance implementation considerations.

For example, `cx_status` bits only accumulate (i.e., are only set, never
cleared, as a side-effect of custom operation instructions that go wrong).
This may simplify a `cx_status` implementation if/when such instructions
may complete out-of-order (e.g., when a first custom operation instruction
is much longer latency than a second such instruction).

Also, it is not until software reads `cx_status` that previously issued
custom instructions must complete, and even then, an out-of-order
processor may value-speculate on `cx_status` to execute ahead of
completion of previously issued custom operation instructions.
====

.`cx_status` CSR 0x801
[wavedrom,target="`cx_status`",svg]
....
{reg:[
{bits:1, name:'IV'},
{bits:1, name:'IC'},
{bits:1, name:'IS'},
{bits:1, name:'OF', attr:'accrued errors'},
{bits:1, name:'IF'},
{bits:1, name:'OP'},
{bits:1, name:'CU'},
{bits: 25, name: 'reserved', type:1},
],
config: {lanes: 1, bits: 32},
}
....

The `cx_status` CSR has the following fields:

`.IV`: invalid CX version error

* Set by a CSR-write to `mcx_selector`, or by a custom operation
instruction, when `mcx_selector.version` is invalid. (For example,
when new software writes a new selector type that old hardware does
not implement.)

[NOTE]
====
Arguably issuing a custom operation instruction with an invalid selector
`version` should raise an illegal-instruction exception. This can only
arise when a fatally broken CX runtime or operation system
issues new version selectors for old version hardware. Raising an
illegal-instruction exception here would be consistent with V extension's
`vtype.vill` behavior.
====

`.IC`: invalid CXU_ID error

* Set by a custom operation instruction when `mcx_selector.cxu_id`
is invalid.

`.IS`: invalid STATE_ID error

* Set by a custom operation instruction when `mcx_selector.cxu_id`
is valid but `mcx_selector`.state_id is invalid.

`.OF`: state context is off error

* Set by a custom operation instruction when `mcx_selector.cxu_id` and
`mcx_selector.state_id` are valid but the selected state context is in
the <<off-state,_off_>> state.

`.IF`: invalid function ID error

* Set by a custom function instruction when `mcx_selector.cxu_id` and
`mcx_selector.state_id` are valid but the instruction's CF_ID is invalid.

* Also set by a custom address CSR access instruction when
`mcx_selector.cxu_id` and `mcx_selector.state_id` are valid but the
custom CSR address is invalid.

`.OP`: CXU operation error

* Set by a custom operation instruction when `mcx_selector.cxu_id`,
`mcx_selector.state_id`, and its CF_ID/CSR address are valid but there
is an error in the requested operation or its operands, in lieu of custom
error state.

`.CU`: custom CXU operation error

* Set by a custom operation instruction of a stateful extension when
`mcx_selector.cxu_id`, `mcx_selector.state_id`, and its CF_ID/CSR
address are valid but there is an error in the requested operation or
its operands, with custom error state available via the `cxs_error`
CX CSR. The CX may also define additional CX instructions and CX CSRs
that retrieve extended error information.

[NOTE]
====
Should writing mcx_selector automatically zero `cx_status`? This shortens
the code path to use an extension by one instruction but it precludes
the use case of clearing errors, issuing a series of custom function
instructions across multiple extensions, *then* checking for errors.

For simplicity we do not adopt this option.
====

[NOTE]
====
How to best anticipate future changes to `cx_status`? One option:
fields and behavior determined by hart's current CX version
(`mcx_selector.version`). This becomes unwieldy when multiplexing
between extensions switches different versions. One option: add a
`cx_status.version` field, selecting an interpretation of `cx_status`
CSR fields. Both options may lead to _unnecessarily complicated_
error handling in software. Best option: only _add_ new fields to it.
Here simplest seems best.
====

==== `mcx_table` CSR 0xBC1: CX selector table base

When CX access control (ยง<<_cx_access_control>>) is supported, the
`MXLEN`-bit-wide `mcx_table` CSR specifies the base address
of the hart's CX selector table. The CSR may be read and written in
machine level.

.mcx_table CSR 0xBC1 (when MXLEN=32)
[wavedrom,target="cx_table",svg]
....
{reg:[
{bits: 12, name: '0'},
{bits: 20, name: 'base_page'},
],
config: {lanes: 1, bits: 32},
}
....

CSR-writes to `mcx_table` zero the twelve least significant
bits of the table address, so a CX selector table address must be 4
KB aligned.

==== `cx_index` CSR 0x800: CX selector index

When CX access control (ยง<<_cx_access_control>>) is supported, the
`cx_index` CSR selects an entry from the hart's CX selector
table entry to write to the `mcx_selector` CSR. The CSR may be read
and written in all privilege levels.

.cx_index CSR 0x800
[wavedrom,target="cx_index",svg]
....
{reg:[
{bits: 10, name: 'index'},
{bits:22, name:'reserved', type:1}
],
config: {lanes: 1, bits: 32},
}
....

The 10-bit zero-extended index field specifies which entry in the hart's
CX selector table (at the hart's `mcx_table`) to use as the
hart's current CX selector.

In response to CSR-write of `cx_index`, load the 32-bit CX
selector at address (`mcx_table + cx_index.index*4`)
and CSR-write the CX selector to `mcx_selector`, performing the load
and the CSR-write at the next higher privilege level, as if it were
a `lw` instruction (and with a `lw` instruction's memory ordering
rules) (ยง<<_cx_access_control>>).

[NOTE]
====
Perhaps _"at the next higher privilege level"_ should be
_"at machine mode privilege level"_.
====

[[fences]]
==== Implicit CX-ISA CSR fences

There is an implicit fence between any CX-ISA CSR access and any series
of custom operation instructions. All CX-ISA CSR accesses happen before
any custom operation instructions which follow, and all custom operation
instructions happen before any CX-ISA CSR accesses that follow.

[TIP]
====
For example, after issuing a long latency CF instruction, a CSR read of
`cx_status` must await the CF instruction's CXU response.
====

=== Custom function instruction encodings

When `mcx_selector.version=1`, software issues CF instructions to the
current state context of the current extension (i.e., of the current
configured CXU) using R-type, I-type, and flex-type custom function
instruction encodings.

For each instruction encoding, the CF instruction specifies the CF_ID, and
source operand values, which may be two source registers, or one source
register and one immediate value. R-type and I-type instructions always
write a destination register whereas flex-type instructions never do so.

==== Custom-0 R-type encoding

Assembly instruction: `cx_reg cf_id,rd,rs1,rs2`

An R-type CF instruction issues a CXU request for a zero-extended 10-bit
CF_ID `cf_id` with two source register operands identified by `rs1` and
`rs2`. The CXU response data is written to destination register `rd`.

.CX R-type instruction encoding
[wavedrom,target="custom-0",svg]
....
{reg:[
{bits: 7, name:11, attr: 'custom-0'},
{bits: 5, name: 'rd'},
{bits: 3, name: 'cf_id[2:0]'},
{bits: 5, name: 'rs1',},
{bits: 5, name: 'rs2'},
{bits: 7, name: 'cf_id[9:3]'},
],
config: {lanes: 1, bits: 32},
}
....

==== Custom-1 I-type encoding

Assembly instruction: `cx_imm cf_id,rd,rs1,imm`

An I-type CF instruction issues a CXU request for a zero-extended 3-bit
CF_ID `cf_id` with one source register operand identified by `rs1` and a
sign-extended 12-bit immediate value `imm`. The CXU response is written
to destination register `rd`.

.CX I-type instruction encoding
[wavedrom,target="custom-1",svg]
....
{reg:[
{bits: 7, name: 43, attr:'custom-1'},
{bits: 5, name: 'rd'},
{bits: 3, name: 'cf_id[2:0]'},
{bits: 5, name: 'rs1'},
{bits: 12, name: 'imm[11:0]'},
],
config: {lanes: 1, bits: 32},
}
....

[NOTE]
====
This encoding uniformly follows existing I-type instructions such as
`addi` and `csrrw`, providing an immediate operand custom function
instruction encoding at zero additional datapath cost.
====

[[custom-2]]
==== Custom-2 flex-type encoding

Assembly instruction: `cx_flex cf_id,rs1,rs2` +
Assembly instruction: `cx_flex25 custom`

A flex-type CF instruction issues a CXU request for a zero-extended
10-bit CF_ID `cf_id` with two source register operands identified by
`rs1` and `rs2`. There is no destination register and CXU response _data_
(but not a possible _error status_) is discarded. The instruction is
executed purely for its effect upon the selected state context of the
selected CXU.

.CX flex-type instruction encoding
[wavedrom,target="custom-2",svg]
....
{reg:[
{bits: 7, name:91, attr: 'custom-2'},
{bits: 5, name: 'custom' },
{bits: 3, name: 'cf_id[2:0]'},
{bits: 5, name: 'rs1',},
{bits: 5, name: 'rs2'},
{bits: 7, name: 'cf_id[9:3]'},
],
config: {lanes: 1, bits: 32},
}
....

Alternatively, equivalently, the `cx_flex25` form of instruction issues
an arbitrary 25-bit custom instruction.

.CX flex-type instruction alternate encoding
[wavedrom,target="custom-2-alt",svg]
....
{reg:[
{bits: 7, name:91, attr: 'custom-2'},
{bits: 25, name: 'custom' },
],
config: {lanes: 1, bits: 32},
}
....

[TIP]
====
A flex-type CF instruction may be used with a CXU-L2 request's raw
instruction field `req_insn` (<<raw-insn>>) to provide an arbitrary
32-7=25-bit custom request to a CXU. The absence of an (integer)
destination register field is a feature that provides added,
CPU-uninterpreted, custom instruction bits to a CXU.
====

[TIP]
====
One disadvantage of this approach: when the selected CXU routinely
discards the R[`rs1`] or R[`rs2`] operands, use of the flex-type custom
function instruction can create a useless false dependency on the `rs1`
and `rs2` registers, which may uselessly delay issue of the CF instruction
in an out-of-order CPU core.
====

=== CX CSR accesses

When `mcx_selector.version=1`, CSR read/write instructions issue custom
CSR accesses (i.e., _CX CSR_ accesses) to the current state context of
the current composable extension.

Per the Priv spec, an attempt to access a custom CSR without appropriate
privilege level raises an illegal-instruction exception and an attempt
to write a read-only custom CSR register raises an illegal-instruction
exception.

Per the Zicsr spec, the only CSR access instructions that do not write
to a CSR are `CSRRS` and `CSRRC` with `rs1=x0` and `CSRRSI` and `CSRRCI`
with `uimm=0`. These are mapped to a CXU request pseudo-instruction
`CSRR`, enabling a CXU to distinguish between a read-write access and a
read-only access. There is no means to distinguish between a CX CSR
read-write access and a write-only access: all CX CSR accesses are read
accesses. There is no need and no means to distinguish between a CX CSR
access using a source value from a source register and the equivalent
access using a source value from the 5-bit `uimm` field.

[wavedrom, ,svg]
....
{reg: [
  {bits: 7,  name: 115, attr: ['SYSTEM']},
  {bits: 5,  name: 'rd',     attr: ['dest', 'dest', 'dest', 'dest', 'dest', 'dest']},
  {bits: 3,  name: 'funct3', attr: ['CSRRW', 'CSRRS', 'CSRRC', 'CSRRWI', 'CSRRSI', 'CSRRCI']},
  {bits: 5,  name: 'rs1',    attr: ['source', 'source', 'source', 'uimm[4:0]', 'uimm[4:0]', 'uimm[4:0]']},
  {bits: 12, name: 'csr',    attr: ['source/dest', 'source/dest', 'source/dest', 'source/dest', 'source/dest', 'source/dest']},
]}
....

In summary CX CSR access instructions are mapped into one of four 
CXU CSR access pseudo-instructions: `CSRR`, `CSRRW`, `CSRRS`, `CSRRR`.

[[multiplexing]]
=== Multiplexing custom instructions and custom CSR accesses across composable extensions

<<execution>> illustrates how custom function instruction and custom
CSR accesses enjoy conflict-free composable extension composition
via composable extension multiplexing. With multiplexing enabled
(`mcx_selector.version=1`), when the CPU issues a custom operation
instruction, it produces a <<cxu_request,CXU request>> from the fields
of the instruction, two source operands from the register file and/or
an immediate field of the instruction, and the `cxu_id` and `state_id`
fields of `mcx_selector`. The CXU request may include the request ID
cookie (defined by the CPU), the <<CXU_ID,CXU_ID>>, <<STATE_ID,STATE_ID>>,
raw instruction, function (<<CF_ID,CF_ID>> or CSR access function), and
operands. The CXU_ID identifies which CXU must process the request. The
CXU includes state context(s) and a datapath. The STATE_ID selects the
state context to use for this request. The CXU checks for errors in
CXU_ID, STATE_ID, and function per <<cx_status>>, processes the request,
possibly updating this state context, and produces a CXU response,
which may include the same request ID cookie, a success/error status,
and the response data. The CPU commits the custom operation instruction
by updating `cx_status` (when response status is an error condition)
and writing the response data to the destination register.

[[execution]]
.HW-SW interface: flow of information for execution of a custom operation instruction
image::cf-instruction-execution.png[image,width=360]

Multiple custom operation instructions may be in flight at the same time,
particularly in a system with pipelined CPUs or pipelined CXUs. A CPU
may send a request ID and later receive the (same) ID back to correlate
requests sent and responses received.

<<mapping>> defines the mapping from HW-SW interface entities, such
as the `cf_id`, `rd`, `rs1`, `rs2`, `imm`, `csr`, `uimm` fields of a
custom function instruction or a custom CSR access instruction and the
`mcx_selector` and `cx_status` CSRs, to the CXU Logic Interface's request
and response signals (ยง<<_cxu_li_signaling>>).

[[mapping]]
.Mapping of HW-SW interface entities to CXU-LI signals
[width="90%",cols="15%,85%",options="header",]
|===
|*CXU-LI signal* |*<- Source or -> Destination*
|`req_id` | <- CPU
|`req_cxu` | <- `mcx_selector.cxu_id`
|`req_state` | <- `mcx_selector.state_id`
|`req_insn` | <- `insn`
|`req_func` | <- `insn.cf_id` {`custom-[012]`} or `csr_func_id(insn)` {`csrr*`}
|`req_data0` | <- R[`insn.rs1`] {`custom-[012]` or `csrr[wsc]`} or `insn.uimm` {`csrr[wsc]i`}
|`req_data1` | <- R[`insn.rs2`] {`custom-[02]`} or `insn.imm` {`custom-1`} or `insn.csr` {`csrr*`}
|`resp_id` | -> CPU
|`resp_status` | -> `cx_status` bits
|`resp_data` | -> R[`insn.rd`] {`custom-[01]` or `csrr*`}
|===

A custom CSR access instruction (`CSRR`, `CSRRW`, `CSRRS`, `CSRRC`) maps
to one of four `req_func` <<FUNC_ID,FUNC_ID>>s with msb set to one to distinguish
them from custom function instructions' `CF_ID` function IDs. In general,
`CXU_FUNC_ID_W = min(3, 1 + CF_ID_W)` bits.

```
enum { CSRR = 1<<CF_ID_W, CSRRW, CSRRS, CSRRC }; // msb set => CSR access
csr_read_only(insn) = (insn.funct3 == CSRR[SR][I]) && (insn.rs1 == 0);
csr_func_id(insn)   = CSRR + (csr_read_only(insn) ? 0 : insn.funct3[1:0]);
```

[NOTE]
====
The signal that distinguishes _custom function instruction_ from _custom CSR
access instruction_ CXU requests is conveyed as the MSB of CXU-LI's `req_func`
<<FUNC_ID,FUNC_ID>>, rather than a separate one bit `req_csr_access` signal, to
minimize the number of CXU-LI signal ports.
====

[[precise]]
==== Precise exceptions

Custom function instruction execution preserves precise exception
semantics. If an instruction preceding (in execution order) a custom
operation instruction is an exception, the custom operation instruction
does not execute, and has no effect upon architected state, including
the `cx_status` CSR, and no effect on the current state context of the
composable extension / CXU.

If an instruction following (in execution order) a custom operation
instruction is an exception, the custom operation instruction executes,
updating destination register, `cx_status`, and current state context,
as appropriate.

[TIP]
====
A CPU may speculatively issue a custom operation instruction to a
stateless CXU. Misspeculation recovery entails completing and discarding
the CXU response. The custom operation instruction does not commit and
there is no change to architectural state.
====

[TIP]
====
A CPU may not speculatively issue a custom operation instruction to a
stateful CXU because the instruction may update the current state context
and the CXU Logic Interface has no means to cancel a CXU request. In
other words, a custom operation instruction of a stateful CXU, once
issued, always commits.
====

[TIP]
====
Speculation is more than branch prediction. For example, in a pipelined
CPU, instructions that follow a load or store instruction typically
issue speculatively until the load or store is determined to not raise
an access fault. Custom operation instructions of stateful CXUs must
not issue in the wake of an instruction that may yet trap.
====

[TIP]
====
When a long latency custom operation instruction issues and a pipelined
CPU continues issuing the following instructions in its wake, and one
traps, the CPU nevertheless commits the custom operation instruction
when the CXU eventually sends the response.
====

[NOTE]
====
How can a CPU core determine dynamically whether a custom function
instruction, or its composable extension, is stateless?  (By definition
custom CSR access instructions are always stateful.)

A software-defined approach could decorate the specification of a custom
function to indicate whether it is stateful or stateless, and to encode
this as an opcode bit in the `custom-[012]` instructions. Then a CPU may
safely speculatively issue stateless CF instructions but non-speculatively
issue stateful CF instructions.

A hardware-defined approach could add to the request and response streams
defined in <<cxu-li,CXU-LI>>, a third stream, called the _commit stream_.
This enables a CPU to speculatively issue any CF instruction and issue
its CXU request, then later, when speculation is resolved, issue its
commit token or cancel token. A stateful CXU, receiving and performing a
CXU request, would defer from updating any CXU state until the request's
corresponding commit token arrives.
====

=== CX State Context CX CSRs

Every stateful CX must implement four _CX State Context CX CSRs_ that
provide a uniform CX programming model:

* `cxs_error`: CX error;

* `scxs_status`: CX state context status;

* `scxs_index`: CX state context index;

* `scxs_data`: CX state context data at index.

The `cxs_` prefix indicates the CSR is a **CX s**tate context CX CSR.

These mandatory CX CSRs enable user-mode CX software to access a CX
state context's error status, and enables a CX-agnostic supervisor-mode
runtime or operating system to manage, initiailze, save, and reload any
CX state context.

[NOTE]
====
Consider abandoning the distinction between stateless and stateful
CXs. Does it add significant benefit or clarity? A level 0 (combinational)
CXU (sans `clk`), if provided, might just have `size=0` and/or
`cxs_error=0`. That's fine.
====

==== CX error (`cxs_error`) CX CSR

The `cxs_error` CX CSR is a *WARL* UXLEN-bit user read-write CX
CSR that conveys the error status of a CX state context. It may be
updated in response to any <<CX_op,CX operation>> and may also be read or
written directly by software via a CSR read/write instruction. As usual
ยง<<fences>> applies.

A CX may implement a `cxs_error` register with fewer than UXLEN bits (as
few as zero bits). Unimplemented most-significant bits always read as 0.

.`cxs_error`: CX error register: user read/write CX CSR: 0x8FF (when UXLEN=32)
[wavedrom,target="`cxs_error`",svg]
....
{reg:[
{bits: 32, name: 'error'},
],
config: {lanes: 1, bits: 32}
}
....

[TIP]
====
While `cxs_error` is inessential, it is mandatory to provide a *uniform*
way for CXs to convey extended error information arising from issuance
of CX operations. This does not preclude a CX provding addtional CX CSRs
or CX instructions to express additional aspects of a CX state context.
====

[NOTE]
====
Proposal: a `cxs_error` value of 0 indicates *no error* (stateful CXs)
or sometimes *sorry, no error information* (stateless CXs??).
====

[NOTE]
====
Each CX defines a behavior contract, indicating which CX operations
set `cxs_error` and to which values. While there is at present no
uniform specification for `cxs_error` values, we expect to discover
and standardize recommended CX error categories and hence uniform
`cxs_error` values.

It remains to be seen whether `cxs_error` should typically *accumulate*
errors or instead capture *the last error* (or success) condition.
====

==== CX state context status (`scxs_status`) CX CSR

The `scxs_status` CX CSR is a *WARL* SXLEN-bit supervisor read-write CX
CSR that tracks and manages the state of a CX state context. It may be
updated in response to any <<CX_op,CX operation>> and may also be read or
written directly by software via a CSR read/write instruction. As usual
ยง<<fences>> applies.

.`scxs_status`: CX state context status register: supervisor read/write CX CSR:0x5FF
[wavedrom,target="scxs_status",svg]
....
{reg:[
{bits: 16, name: 'size'},
{bits: 10, name: 'reserved', type:1},
{bits: 1, name: 'rst'},
{bits: 2, name: 'cs'},
{bits: 3, name: 0, attr:'version'},
]}
....

The `scxs_status` register has these fields:

`.cs`: state context status

* The state context status has four state values: { 0: `off`; 1:
`initial`; 2: `clean`; 3: `dirty` }, corresponding to those of the `XS`
field of the `mstatus` CSR, per the RISC-V Privileged ISA specification
cite:[risc-v-priv(26)].

* On system reset, each state context of a stateful extension is in the
`initial` state.

[[off-state]]
* A write `.cs=0` has the side effect of explicitly turning off the
_current_ state context. In this state, all CX custom instructions
signal `CXU_ERROR_OFF` and set `cx_status.OF`.

[NOTE]
====
In this state, what do CX CSR accesses do?
====

[NOTE]
====
Is state preserved, disturbed, reset, or left _undefined_, by setting
a state context to the `off` state, then to another state?
====

`.rst`: state context reset control/status

* A write `.rst=1` resets the _current_ state context to its initial
(power up) state. This may be instantaneous, or it may take many cycles.

* While the state context reset is in progress, `scxs_status.rst == 1`.
In this state, as with the `off` state, all CX custom instructions signal
`CXU_ERROR_OFF` and set `cx_status.OF`.

[NOTE]
====
In this state, what do CX CSR accesses do?
====

* When a CXU implements mulitple CX state contexts, and state context
reset requires many clock cycles, it is possible for software to rapidly
select and reset multiple CX state contexts, even before the first
reset completes.

* When a CX custom instruction or CX CSR access modifies any aspect of the
current state context, its state context status automatically changes to
`dirty`.

`.size`: state context size

* This WARL field specifies the _current_ size (number of XLEN-sized
words) of the current state context.

* Reads return the current size of the current state context.

* The value read need not equal the last value written.

* Writes return the previous size and `cs` status of the current state context.

* Different CXU implementations of the same composable extension may have
different state context sizes.

* Different state contexts of the same CXU may have different state context sizes.

* At different times, the same state context of the same CXU may have different state context sizes.

==== CX state context index (`scxs_index`) and CX state context data (`scxs_data`) CX CSRs

Together `scxs_status.size`, `scxs_index`, and `scxs_data` provide a
CX-agnostic way for software to save a CX state context to a state context
save record _blob_, and later to reload the context from the blob data.

Software should not interpret the blob data. In different systems,
the different CXUs that implement a CX may use different blob formats
and sizes.

The `scxs_index` CX CSR is a *WARL* SXLEN-bit supervisor read-write CX
CSR that specifies the index and optional index auto-increment of 
access(es) of CX state context data.

A CX may implement its `scxs_index` CX CSR with fewer than 16 bits (as
few as zero bits). Unimplemented most-significant bits always read as 0.

Its `.index` field specifies the index, within the current CX state
context's context save data, that is accessed by a CSR read or write of
the `scxs_data` CX CSR.

Its `.incr` field specifies that each time a CSR read or write of
`scxs_data` commits, `scxs_index.index` is incremented by one. Thus
software may read, e.g., the first three words of the current CX state
context using:

[source,asm]
....
li a0,0x80000000
csrw scxs_index,a0	// .index = 0
csrr a1,scxs_data	// .index = 1
csrr a2,scxs_data	// .index = 2
csrr a3,scxs_data	// .index = 3
....

Whenever the `.index` field is written with a value greater or equal to
`scxs_status.state`, it is zeroed: `scxs_index.index = 0`.

.`scxs_index`: CX state context index register: supervisor read/write CX CSR:0x5FE
[wavedrom,target="`scxs_index`",svg]
....
{reg:[
{bits: 16, name: 'index'},
{bits: 15, name: 'reserved', type:1},
{bits: 1, name: 'incr'},
],
config: {lanes: 1, bits: 32}
}
....


.`scxs_data`: CX state context data register: supervisor read/write CX CSR:0x5FD (when SXLEN=32)
[wavedrom,target="`scxs_data`",svg]
....
{reg:[
{bits: 32, name: 'data'},
],
config: {lanes: 1, bits: 32}
}
....

[NOTE]
====
TODO: define reserved ranges of CX CSRs
====

=== CX/CXU identity CX CSRs

[TIP]
====
This entire CX/CXU info CX CSRs section is provisional and non-normative.
====

Two sets of optional machine-mode read-only CX CSRs allow software to
interrogate the identity of the selected CX (<<CX_GUID,CX_GUID>>) or its
CXU (<<CXU_GUID,CXU_GUID>>).

[TIP]
====
These are machine mode only because they are only useful to system
software and should not be used by user mode CX software. To select a
CX, CX software has already discovered it via its <<CX_GUID,CX_GUID>>.
CX software must not depend on specific CXU implementations or versions --
all implement a specific CX ISA contract, all should behave identically.
====

==== 32-bit CX_GUID (`mcx_guid[0123]`) CX CSRs

.`mcx_guid0` CX_GUID-0 register: machine read-only CX CSR:0x8FF (when UXLEN=32)
[wavedrom,target="`mcx_guid0`",svg]
....
{reg:[
{bits: 32, name: 'cx_guid[31:0]'},
],
config: {lanes: 1, bits: 32}
}
....

.`mcx_guid1` CX_GUID-1 register: machine read-only CX CSR:0x8FF (when UXLEN=32)
[wavedrom,target="`mcx_guid1`",svg]
....
{reg:[
{bits: 32, name: 'cx_guid[63:32]'},
],
config: {lanes: 1, bits: 32}
}
....

.`mcx_guid2` CX_GUID-2 register: machine read-only CX CSR:0x8FF (when UXLEN=32)
[wavedrom,target="`mcx_guid2`",svg]
....
{reg:[
{bits: 32, name: 'cx_guid[95:64]'},
],
config: {lanes: 1, bits: 32}
}
....

.`mcx_guid3` CX_GUID-3 register: machine read-only CX CSR:0x8FF (when UXLEN=32)
[wavedrom,target="`mcx_guid3`",svg]
....
{reg:[
{bits: 32, name: 'cx_guid[127:96]'},
],
config: {lanes: 1, bits: 32}
}
....

==== 64-bit CX_GUID (`mcx_guid[01]`) CX CSRs

.`mcx_guid0` CX_GUID-0 register: machine read-only CX CSR:0x8FF (when UXLEN=64)
[wavedrom,target="`mcx_guid0-64`",svg]
....
{reg:[
{bits: 64, name: 'cx_guid[63:0]'},
],
config: {lanes: 1, bits: 64}
}
....

.`mcx_guid1` CX_GUID-1 register: machine read-only CX CSR:0x8FF (when UXLEN=64)
[wavedrom,target="`mcx_guid1-64`",svg]
....
{reg:[
{bits: 64, name: 'cx_guid[127:64]'},
],
config: {lanes: 1, bits: 64}
}
....

==== 32-bit CXU_GUID (`mcxu_guid[0123]`) CX CSRs

.`mcxu_guid0` CXU_GUID-0 register: machine read-only CX CSR:0x8FF (when UXLEN=32)
[wavedrom,target="`mcxu_guid0`",svg]
....
{reg:[
{bits: 32, name: 'cxu_guid[31:0]'},
],
config: {lanes: 1, bits: 32}
}
....

.`mcxu_guid1` CXU_GUID-1 register: machine read-only CX CSR:0x8FF (when UXLEN=32)
[wavedrom,target="`mcxu_guid1`",svg]
....
{reg:[
{bits: 32, name: 'cxu_guid[63:32]'},
],
config: {lanes: 1, bits: 32}
}
....

.`mcxu_guid2` CXU_GUID-2 register: machine read-only CX CSR:0x8FF (when UXLEN=32)
[wavedrom,target="`mcxu_guid2`",svg]
....
{reg:[
{bits: 32, name: 'cxu_guid[95:64]'},
],
config: {lanes: 1, bits: 32}
}
....

.`mcxu_guid3` CXU_GUID-3 register: machine read-only CX CSR:0x8FF (when UXLEN=32)
[wavedrom,target="`mcxu_guid3`",svg]
....
{reg:[
{bits: 32, name: 'cxu_guid[127:96]'},
],
config: {lanes: 1, bits: 32}
}
....

==== 64-bit CX_GUID (`mcxu_guid[01]`) CX CSRs

.`mcxu_guid0` CXU_GUID-0 register: machine read-only CX CSR:0x8FF (when UXLEN=64)
[wavedrom,target="`mcxu_guid0-64`",svg]
....
{reg:[
{bits: 64, name: 'cxu_guid[63:0]'},
],
config: {lanes: 1, bits: 64}
}
....

.`mcxu_guid1` CXU_GUID-1 register: machine read-only CX CSR:0x8FF (when UXLEN=64)
[wavedrom,target="`mcxu_guid1-64`",svg]
....
{reg:[
{bits: 64, name: 'cxu_guid[127:64]'},
],
config: {lanes: 1, bits: 64}
}
....

[[IStateContext]]
=== `IStateContext`: the standard custom functions


==== `cx_read_status` standard custom function instruction

Assembly instruction: `cx_read_status rd`

This instruction retrieves the state status word
(ยง<<_extension_state_context_status_word>>) of the selected state context
of the selected CXU and writes it to the `rd` destination register.

`cx_read_status` can never modify the selected state context, nor modify
the behavior of the extension.

The status word `.size` field may change as a side effect of
executing a stateful CF instruction.

For the CF instruction sequence [ `cx_read_status`; `cx_read_state`*;
`cx_read_status` ], the first and second `cx_read_status` must return
the same `.size`.

For the CF instruction sequence [ `cx_read_status`,
_any-other-CF-instruction_ *, `cx_read_status` ], the first and second
`cx_read_status` need not return the same `.size`.

[TIP]
====
For most stateful CXUs, the size of a state context is fixed. For some
stateful CXUs, the size of a state context may depend upon the sequence
of CF instructions performed. For example, a stateful vector math CXU may
provide CF instructions to allocate per-state context vector storage from
a common, private shared pool, and may allow different state contexts
to represent different sized vectors.
====

`cx_read_status` may be used as a _probe_ after a `mcx_selector` write,
to check whether the selector addresses a valid CXU and state context:

[source,asm]
....
csrw mcx_selector,x1    ; select some CXU and state context
csrw cx_status,x0       ; clear cx_status
cx_read_status x0       ; probe, discarding state status word
csrr x2,cx_status       ; retrieve cx_status
...                     ; cx_status.ci => invalid CXU_ID
...                     ; cx_status.si => invalid STATE_ID
....

==== `cx_write_status` standard custom function instruction

Assembly instruction: `cx_write_status rs1`

This instruction writes the value of the `rs1` source register to the
state status word of the selected state context of the selected CXU,
and writes the previous value of the state context status word to the
`rd` destination register.

A write `.cs=1` always has the side effect of resetting the selected
state context to its initial (power up) state.

For the sequence [ `cx_write_status`; *; `cx_read_status` ] the value of
`.size` read need not equal the last value written.

A `cx_write_status` CF instruction never has any effect upon any other
state context of the CXU, or of any other CXU.

==== `cx_read_state` standard custom function instruction

Assembly instruction: `cx_read_state rd,rs1`

This instruction reads one (XLEN-bit) word of state, at the index
specified by the `rs1` source register, from the selected state context
of the selected CXU, and writes it to the `rd` destination register.

==== `cx_write_state` standard custom function instruction

Assembly instruction: `cx_write_state rs1,rs2`

This instruction reads the value of the `rs2` source register and writes
it to the selected state context of the selected CXU at the index
specified by the value of the `rs1` source register.
It also writes the value of the `rs2` source register to the `rd`
destination register. It silently drops attempts to write state at an
invalid state index.

=== Resource management and context switching

A software resource manager (e.g., thread pool, language runtime, language
virtual machine, RTOS, operating system, hypervisor) multiplexes software
loci of execution (e.g., request, worker, actor, activity, task, fiber,
continuation, thread, process), _locus_ for short, upon one or more
hardware threads (_harts_).

The RISC-V per-hart state includes the program counter and integer
register file, and optionally, floating point and vector register files,
and various CSRs. CX-ISA extends per-hart state with the CX-ISA CSRs
(ยง<<cx_isa_csrs>>) and the subset of the various configured state
contexts of the stateful configured composable extensions allocated to
that hart.

A CXU implementing a stateful composable extension is typically configured
with one state context per hart in the entire system, but other
configurations, including one context per locus, or a small pool
of cooperatively or preemptively managed contexts, or several harts
sharing one context, or one singleton context, are possible. Similarly,
each CXU in a system may be configured with a different number of its
state contexts.

The resource manager maintains the mapping of loci to harts, and the
mapping of harts to (per-CXU) state contexts. The resource manager
consults a _system CXU map_ specifying the mapping CXU_IDs of the
configured extensions of the system, and for each extension/CXU, the
no. of state contexts it is configured with. A stateless CXU has zero
contexts.

Over time, the resource manager must reset, save, and restore hart state,
including its extension state contexts, to initialize a hart or
to perform a context switch.

To reset hart state, for each extension state context of the hart, execute

[source,asm]
....
li a1,{.error=0,.cs=1/*initialize*/}
lw a0,selectors[i]
csrw mcx_selector,a0
cx_write_status a1
....

This resets that state context to its initial state. It is also necessary
to reset `cx_status`.

[source,asm]
....
csrw cx_status,x0
....

To save hart state, first save `cx_status`, then
for each extension state context of the hart,
execute

[source,asm]
....
csrr a0,cx_status
sw a0,saved_cx_status
...
lw a0,selectors[i]
csrw mcx_selector,a0
cx_read_status a0
sw a0,status[i]
....

to obtain `.size`, the size (in XLEN-bit words) of the state context
blob for the selected state context. Allocate array `save[i][]` to store
the serialized state context. For each word in `.size`, execute

[source,asm]
....
cx_read_state a0,j
sw/sd a0, save[i][j]
....

(When XLEN=32, use `sw`; when XLEN=64, use `sd`.)

To restore hart state, for each extension state context of the hart,
first execute

[source,asm]
....
lw a0, selectors[i]
csrw mcx_selector, a0
lw a0, status[i]
cx_write_status a0
....

to restore the state context status word. Then for each word in
`status[i].size`, execute

[source,asm]
....
lw/ld a0, save[i][j]
cx_write_state j,a0
....

to restore each word of the state context. Finally restore the
saved `cx_status`.

[source,asm]
....
lw a0,saved_cx_status
csrw cx_status,a0
....

When different CXUs implement the same composable extension, they may have
different serializations, of different sizes.

[NOTE]
====
Discuss preemption scenario where following context save, later restore,
the locus moves to a different STATE_ID of a CXU. `cx_index`
may (but should not) change. However, resource manager must change
`mcx_selector`.
====

[NOTE]
====
`cf_read_state` and `cf_write_state` are random access. It is
possible this induces unnecessary CXU hardware area. Perhaps specify a
stream-out/stream-in extension instead.
====

[NOTE]
====
Discuss impact of mixed sized state contexts blobs upon system code and
upon CXU design. Can a state context blob ever be too big to reload?
====

[NOTE]
====
Is it necessary or helpful for CXU metadata to declare fixed- or
variable-sized extension state contexts?
====

=== CX access control

Fully trusted software, executing in machine level, has full access
to every CXU and every state context. Software may write an arbitrary
CX selector value to the `mcx_selector` CSR, addressing any CXU and
any state context. This is sufficient to implement composable extension
multiplexing but does not provide means to protect one hart's CXUs'
state from another hart, nor to limit a hart's access to a given CXU.

When a CPU implements user level and machine level privileged
architecture, an attempt to CSR-write `mcx_selector` from user level
generates an illegal-instruction exception.

Machine level software may provide to user level software an `ECALL`
function to change `mcx_selector`.

Alternatively, the machine level illegal-instruction exception handler
can determine whether the new CX selector value is valid for the user
level code executing on the hart, optionally perform the CSR-write on its
behalf, and return from exception.

Whether `ECALL` or exception handler, a detour into system level
is prohibitively slow: reconfiguring composable extension multiplexing
should take, at most, a few clock cycles.

The optional CX access control CSRs `mcx_table` and
`cx_index` allow less privileged _user code_ to rapidly
multiplex composable extensions, but only among those extensions and state
contexts that it is granted access by more privileged _system code_.

CX access control requires at least user level and machine level
privileged architecture, and a memory access control system, i.e.,
either RISC-V PMP or RISC-V virtual memory access control.

For each hart, the system code provisions a <<selector-table,_CX selector
table_>>, 4 KB aligned, comprising 1024 32-bit CX selectors, which is
read/write to system code and inaccessible from user code.

Initially the table is initialized with 0 in the 0th entry, and the
invalid selector (`0x10000000`) in every other entry. Selector index 0 
selects table entry 0, with value `0x0000000` = `'{version:0, cxe:0}`,
which disables CX multiplexing, thereby selecting the CPU's built-in
custom instructions and custom CSRs. The system code CSR-writes the
table address to the hart's `mcx_table` CSR. Then in response to a system
call requesting access to a composable extension and one of its state
contexts, system code determines whether the access is granted. If so,
it determines the CX selector value for it, allocates an entry for that
CX selector value in the CX selector table, and returns the index (the
_selector index)_ of that entry to user code.

[TIP]
====
This index is analogous to a Unix file descriptor -- an opaque token to
a resource granted by system code.
====

To select this CX/CXU and its state, user code CSR-writes its index
to `cx_index`. In response, the CPU loads from memory (at more
privileged level) the CX selector word at that index in the selector table
and copies it (CSR-writes it) to `mcx_selector` -- no OS detour required.

[TIP]
====
This mechanism also conceals the specific CXU_ID and STATE_ID information
from user code, precluding some possible side channel attacks.
====
